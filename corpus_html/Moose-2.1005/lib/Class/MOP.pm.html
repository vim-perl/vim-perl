<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title>[untitled]</title>
  <link rel="stylesheet" type="text/css" href="../../t/vim_syntax.css" />
 </head>
 <body>

<pre>
<span class="synStatement">package</span><span class="synType"> Class::MOP</span>;
<span class="synPreProc">BEGIN </span>{
  <span class="synIdentifier">$</span><span class="synType">Class::MOP::</span><span class="synIdentifier">AUTHORITY</span> = <span class="synString">'cpan:STEVAN'</span>;
}
{
  <span class="synIdentifier">$</span><span class="synType">Class::MOP::</span><span class="synIdentifier">VERSION</span> = <span class="synString">'2.1005'</span>;
}

<span class="synStatement">use strict</span>;
<span class="synStatement">use warnings</span>;

<span class="synStatement">use </span><span class="synFloat">5.008</span>;

<span class="synStatement">use </span>MRO::Compat;

<span class="synStatement">use </span>Carp          <span class="synString">'confess'</span>;
<span class="synStatement">use </span>Class::Load <span class="synFloat">0.07</span> ();
<span class="synStatement">use </span>Scalar::Util  <span class="synString">'weaken'</span>, <span class="synString">'isweak'</span>, <span class="synString">'reftype'</span>, <span class="synString">'blessed'</span>;
<span class="synStatement">use </span>Data::OptList;
<span class="synStatement">use </span>Try::Tiny;

<span class="synStatement">use </span>Class::MOP::Mixin::AttributeCore;
<span class="synStatement">use </span>Class::MOP::Mixin::HasAttributes;
<span class="synStatement">use </span>Class::MOP::Mixin::HasMethods;
<span class="synStatement">use </span>Class::MOP::Class;
<span class="synStatement">use </span>Class::MOP::Attribute;
<span class="synStatement">use </span>Class::MOP::Method;

<span class="synPreProc">BEGIN </span>{
    *IS_RUNNING_ON_5_10 = (<span class="synIdentifier">$]</span> &lt; <span class="synFloat">5.009_005</span>)
        ? <span class="synKeyword">sub </span><span class="synType">() </span>{ <span class="synNumber">0</span> }
        : <span class="synKeyword">sub </span><span class="synType">() </span>{ <span class="synNumber">1</span> };

    <span class="synComment"># this is either part of core or set up appropriately by MRO::Compat</span>
    *check_package_cache_flag = \<span class="synIdentifier">&amp;</span><span class="synType">mro::</span><span class="synIdentifier">get_pkg_gen</span>;
}

XSLoader::load(
    <span class="synString">'Moose'</span>,
    <span class="synIdentifier">$</span><span class="synType">Class::</span><span class="synIdentifier">MOP::{</span><span class="synString">VERSION</span><span class="synIdentifier">}</span> ? <span class="synIdentifier">${</span> <span class="synIdentifier">$</span><span class="synType">Class::</span><span class="synIdentifier">MOP::{</span><span class="synString">VERSION</span><span class="synIdentifier">}</span> <span class="synIdentifier">}</span> : ()
);

{
    <span class="synComment"># Metaclasses are singletons, so we cache them here.</span>
    <span class="synComment"># there is no need to worry about destruction though</span>
    <span class="synComment"># because they should die only when the program dies.</span>
    <span class="synComment"># After all, do package definitions even get reaped?</span>
    <span class="synComment"># Anonymous classes manage their own destruction.</span>
    <span class="synStatement">my</span> <span class="synIdentifier">%METAS</span>;

    <span class="synKeyword">sub </span><span class="synFunction">get_all_metaclasses         </span>{        <span class="synIdentifier">%METAS</span>         }
    <span class="synKeyword">sub </span><span class="synFunction">get_all_metaclass_instances </span>{ <span class="synStatement">values</span> <span class="synIdentifier">%METAS</span>         }
    <span class="synKeyword">sub </span><span class="synFunction">get_all_metaclass_names     </span>{ <span class="synStatement">keys</span>   <span class="synIdentifier">%METAS</span>         }
    <span class="synKeyword">sub </span><span class="synFunction">get_metaclass_by_name       </span>{ <span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span>         }
    <span class="synKeyword">sub </span><span class="synFunction">store_metaclass_by_name     </span>{ <span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span> = <span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]</span> }
    <span class="synKeyword">sub </span><span class="synFunction">weaken_metaclass            </span>{ weaken(<span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span>) }
    <span class="synKeyword">sub </span><span class="synFunction">metaclass_is_weak           </span>{ isweak(<span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span>) }
    <span class="synKeyword">sub </span><span class="synFunction">does_metaclass_exist        </span>{ <span class="synStatement">exists</span> <span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span> &amp;&amp; <span class="synOperator">defined</span> <span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span> }
    <span class="synKeyword">sub </span><span class="synFunction">remove_metaclass_by_name    </span>{ <span class="synStatement">delete</span> <span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span>; <span class="synStatement">return</span> }

    <span class="synComment"># This handles instances as well as class names</span>
    <span class="synKeyword">sub </span><span class="synFunction">class_of </span>{
        <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = blessed(<span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span>) || <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span>;
        <span class="synStatement">return</span> <span class="synIdentifier">$METAS{$class}</span>;
    }

    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># We only cache metaclasses, meaning instances of</span>
    <span class="synComment"># Class::MOP::Class. We do not cache instance of</span>
    <span class="synComment"># Class::MOP::Package or Class::MOP::Module. Mostly</span>
    <span class="synComment"># because I don't yet see a good reason to do so.</span>
}

<span class="synKeyword">sub </span><span class="synFunction">load_class </span>{
    <span class="synStatement">goto</span> <span class="synIdentifier">&amp;</span><span class="synType">Class::Load::</span><span class="synIdentifier">load_class</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">load_first_existing_class </span>{
    <span class="synStatement">goto</span> <span class="synIdentifier">&amp;</span><span class="synType">Class::Load::</span><span class="synIdentifier">load_first_existing_class</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">is_class_loaded </span>{
    <span class="synStatement">goto</span> <span class="synIdentifier">&amp;</span><span class="synType">Class::Load::</span><span class="synIdentifier">is_class_loaded</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_definition_context </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">%context</span>;
    <span class="synIdentifier">@context{</span><span class="synString">qw(package file line)</span><span class="synIdentifier">}</span> = <span class="synStatement">caller</span>(<span class="synNumber">1</span>);

    <span class="synStatement">return</span> (
        <span class="synString">definition_context</span> =&gt; \<span class="synIdentifier">%context</span>,
    );
}

<span class="synComment">## ----------------------------------------------------------------------------</span>
<span class="synComment">## Setting up our environment ...</span>
<span class="synComment">## ----------------------------------------------------------------------------</span>
<span class="synComment">## Class::MOP needs to have a few things in the global perl environment so</span>
<span class="synComment">## that it can operate effectively. Those things are done here.</span>
<span class="synComment">## ----------------------------------------------------------------------------</span>

<span class="synComment"># ... nothing yet actually ;)</span>

<span class="synComment">## ----------------------------------------------------------------------------</span>
<span class="synComment">## Bootstrapping</span>
<span class="synComment">## ----------------------------------------------------------------------------</span>
<span class="synComment">## The code below here is to bootstrap our MOP with itself. This is also</span>
<span class="synComment">## sometimes called &quot;tying the knot&quot;. By doing this, we make it much easier</span>
<span class="synComment">## to extend the MOP through subclassing and such since now you can use the</span>
<span class="synComment">## MOP itself to extend itself.</span>
<span class="synComment">##</span>
<span class="synComment">## Yes, I know, that's weird and insane, but it's a good thing, trust me :)</span>
<span class="synComment">## ----------------------------------------------------------------------------</span>

<span class="synComment"># We need to add in the meta-attributes here so that</span>
<span class="synComment"># any subclass of Class::MOP::* will be able to</span>
<span class="synComment"># inherit them using _construct_instance</span>

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Mixin::HasMethods</span>

Class::MOP::Mixin::HasMethods-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'_methods'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'_method_map'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::HasMethods::</span><span class="synIdentifier">_method_map</span>
        },
        <span class="synString">default</span> =&gt; <span class="synKeyword">sub </span>{ {} },
        _definition_context(),
    ))
);

Class::MOP::Mixin::HasMethods-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'method_metaclass'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'method_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::HasMethods::</span><span class="synIdentifier">method_metaclass</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synString">'Class::MOP::Method'</span>,
        _definition_context(),
    ))
);

Class::MOP::Mixin::HasMethods-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'wrapped_method_metaclass'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'wrapped_method_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::HasMethods::</span><span class="synIdentifier">wrapped_method_metaclass</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synString">'Class::MOP::Method::Wrapped'</span>,
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Mixin::HasMethods</span>

Class::MOP::Mixin::HasAttributes-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'attributes'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to do this in order</span>
            <span class="synComment"># for the instance meta-object to</span>
            <span class="synComment"># not fall into meta-circular death</span>
            <span class="synComment">#</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'_attribute_map'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::HasAttributes::</span><span class="synIdentifier">_attribute_map</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ {} },
        _definition_context(),
    ))
);

Class::MOP::Mixin::HasAttributes-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'attribute_metaclass'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'attribute_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::HasAttributes::</span><span class="synIdentifier">attribute_metaclass</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synString">'Class::MOP::Attribute'</span>,
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Package</span>

Class::MOP::Package-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'package'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to do this in order</span>
            <span class="synComment"># for the instance meta-object to</span>
            <span class="synComment"># not fall into meta-circular death</span>
            <span class="synComment">#</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'name'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Package::</span><span class="synIdentifier">name</span>
        },
        _definition_context(),
    ))
);

Class::MOP::Package-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'namespace'</span> =&gt; (
        <span class="synString">reader</span> =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'namespace'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Package::</span><span class="synIdentifier">namespace</span>
        },
        <span class="synString">init_arg</span> =&gt; <span class="synOperator">undef</span>,
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ \<span class="synOperator">undef</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Module</span>

<span class="synComment"># </span><span class="synTodo">NOTE:</span>
<span class="synComment"># yeah this is kind of stretching things a bit,</span>
<span class="synComment"># but truthfully the version should be an attribute</span>
<span class="synComment"># of the Module, the weirdness comes from having to</span>
<span class="synComment"># stick to Perl 5 convention and store it in the</span>
<span class="synComment"># $VERSION package variable. Basically if you just</span>
<span class="synComment"># squint at it, it will look how you want it to look.</span>
<span class="synComment"># Either as a package variable, or as a attribute of</span>
<span class="synComment"># the metaclass, isn't abstraction great :)</span>

Class::MOP::Module-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'version'</span> =&gt; (
        <span class="synString">reader</span> =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'version'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Module::</span><span class="synIdentifier">version</span>
        },
        <span class="synString">init_arg</span> =&gt; <span class="synOperator">undef</span>,
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ \<span class="synOperator">undef</span> },
        _definition_context(),
    ))
);

<span class="synComment"># </span><span class="synTodo">NOTE:</span>
<span class="synComment"># By following the same conventions as version here,</span>
<span class="synComment"># we are opening up the possibility that people can</span>
<span class="synComment"># use the $AUTHORITY in non-Class::MOP modules as</span>
<span class="synComment"># well.</span>

Class::MOP::Module-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'authority'</span> =&gt; (
        <span class="synString">reader</span> =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'authority'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Module::</span><span class="synIdentifier">authority</span>
        },
        <span class="synString">init_arg</span> =&gt; <span class="synOperator">undef</span>,
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ \<span class="synOperator">undef</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Class</span>

Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'superclasses'</span> =&gt; (
        <span class="synString">accessor</span> =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'superclasses'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">superclasses</span>
        },
        <span class="synString">init_arg</span> =&gt; <span class="synOperator">undef</span>,
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ \<span class="synOperator">undef</span> },
        _definition_context(),
    ))
);

Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'instance_metaclass'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to do this in order</span>
            <span class="synComment"># for the instance meta-object to</span>
            <span class="synComment"># not fall into meta-circular death</span>
            <span class="synComment">#</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'instance_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">instance_metaclass</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synString">'Class::MOP::Instance'</span>,
        _definition_context(),
    ))
);

Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'immutable_trait'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'immutable_trait'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">immutable_trait</span>
        },
        <span class="synString">default</span> =&gt; <span class="synString">&quot;Class::MOP::Class::Immutable::Trait&quot;</span>,
        _definition_context(),
    ))
);

Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'constructor_name'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'constructor_name'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">constructor_name</span>,
        },
        <span class="synString">default</span> =&gt; <span class="synString">&quot;new&quot;</span>,
        _definition_context(),
    ))
);

Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'constructor_class'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'constructor_class'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">constructor_class</span>,
        },
        <span class="synString">default</span> =&gt; <span class="synString">&quot;Class::MOP::Method::Constructor&quot;</span>,
        _definition_context(),
    ))
);


Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'destructor_class'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'destructor_class'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">destructor_class</span>,
        },
        _definition_context(),
    ))
);

<span class="synComment"># </span><span class="synTodo">NOTE:</span>
<span class="synComment"># we don't actually need to tie the knot with</span>
<span class="synComment"># Class::MOP::Class here, it is actually handled</span>
<span class="synComment"># within Class::MOP::Class itself in the</span>
<span class="synComment"># _construct_class_instance method.</span>

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Mixin::AttributeCore</span>
Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'name'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to do this in order</span>
            <span class="synComment"># for the instance meta-object to</span>
            <span class="synComment"># not fall into meta-circular death</span>
            <span class="synComment">#</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'name'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">name</span>
        },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'accessor'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'accessor'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">accessor</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_accessor'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_accessor</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'reader'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'reader'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">reader</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_reader'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_reader</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'initializer'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'initializer'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">initializer</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_initializer'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_initializer</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'definition_context'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'definition_context'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">definition_context</span>     },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'writer'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'writer'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">writer</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_writer'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_writer</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'predicate'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'predicate'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">predicate</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_predicate'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_predicate</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'clearer'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'clearer'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">clearer</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_clearer'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_clearer</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'builder'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'builder'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">builder</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_builder'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_builder</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'init_arg'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'init_arg'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">init_arg</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_init_arg'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_init_arg</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'default'</span> =&gt; (
        <span class="synComment"># default has a custom 'reader' method ...</span>
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_default'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_default</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'insertion_order'</span> =&gt; (
        <span class="synString">reader</span>      =&gt; { <span class="synString">'insertion_order'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">insertion_order</span> },
        <span class="synString">writer</span>      =&gt; { <span class="synString">'_set_insertion_order'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">_set_insertion_order</span> },
        <span class="synString">predicate</span>   =&gt; { <span class="synString">'has_insertion_order'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_insertion_order</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Attribute</span>
Class::MOP::Attribute-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'associated_class'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to do this in order</span>
            <span class="synComment"># for the instance meta-object to</span>
            <span class="synComment"># not fall into meta-circular death</span>
            <span class="synComment">#</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'associated_class'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Attribute::</span><span class="synIdentifier">associated_class</span>
        },
        _definition_context(),
    ))
);

Class::MOP::Attribute-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'associated_methods'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'associated_methods'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Attribute::</span><span class="synIdentifier">associated_methods</span> },
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ [] },
        _definition_context(),
    ))
);

Class::MOP::Attribute-&gt;meta-&gt;add_method(<span class="synString">'clone'</span> =&gt; <span class="synKeyword">sub </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span>  = <span class="synStatement">shift</span>;
    <span class="synIdentifier">$self-&gt;meta-&gt;clone_object</span>(<span class="synIdentifier">$self</span>, <span class="synIdentifier">@_</span>);
});

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method</span>
Class::MOP::Method-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'body'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'body'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">body</span> },
        _definition_context(),
    ))
);

Class::MOP::Method-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'associated_metaclass'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'associated_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">associated_metaclass</span> },
        _definition_context(),
    ))
);

Class::MOP::Method-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'package_name'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'package_name'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">package_name</span> },
        _definition_context(),
    ))
);

Class::MOP::Method-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'name'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'name'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">name</span> },
        _definition_context(),
    ))
);

Class::MOP::Method-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'original_method'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'original_method'</span>      =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">original_method</span> },
        <span class="synString">writer</span>   =&gt; { <span class="synString">'_set_original_method'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">_set_original_method</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method::Wrapped</span>

<span class="synComment"># </span><span class="synTodo">NOTE:</span>
<span class="synComment"># the way this item is initialized, this</span>
<span class="synComment"># really does not follow the standard</span>
<span class="synComment"># practices of attributes, but we put</span>
<span class="synComment"># it here for completeness</span>
Class::MOP::Method::Wrapped-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'modifier_table'</span> =&gt; (
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method::Generated</span>

Class::MOP::Method::Generated-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'is_inline'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'is_inline'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Generated::</span><span class="synIdentifier">is_inline</span> },
        <span class="synString">default</span>  =&gt; <span class="synNumber">0</span>,
        _definition_context(),
    ))
);

Class::MOP::Method::Generated-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'definition_context'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'definition_context'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Generated::</span><span class="synIdentifier">definition_context</span> },
        _definition_context(),
    ))
);


<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method::Inlined</span>

Class::MOP::Method::Inlined-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'_expected_method_class'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'_expected_method_class'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Inlined::</span><span class="synIdentifier">_expected_method_class</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method::Accessor</span>

Class::MOP::Method::Accessor-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'attribute'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'associated_attribute'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Accessor::</span><span class="synIdentifier">associated_attribute</span>
        },
        _definition_context(),
    ))
);

Class::MOP::Method::Accessor-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'accessor_type'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'accessor_type'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Accessor::</span><span class="synIdentifier">accessor_type</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method::Constructor</span>

Class::MOP::Method::Constructor-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'options'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'options'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Constructor::</span><span class="synIdentifier">options</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ +{} },
        _definition_context(),
    ))
);

Class::MOP::Method::Constructor-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'associated_metaclass'</span> =&gt; (
        <span class="synString">init_arg</span> =&gt; <span class="synString">&quot;metaclass&quot;</span>, <span class="synComment"># </span><span class="synTodo">FIXME</span><span class="synComment"> alias and rename</span>
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'associated_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Constructor::</span><span class="synIdentifier">associated_metaclass</span>
        },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Instance</span>

<span class="synComment"># </span><span class="synTodo">NOTE:</span>
<span class="synComment"># these don't yet do much of anything, but are just</span>
<span class="synComment"># included for completeness</span>

Class::MOP::Instance-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'associated_metaclass'</span>,
        <span class="synString">reader</span>   =&gt; { <span class="synString">associated_metaclass</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Instance::</span><span class="synIdentifier">associated_metaclass</span> },
        _definition_context(),
    ),
);

Class::MOP::Instance-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'_class_name'</span>,
        <span class="synString">init_arg</span> =&gt; <span class="synOperator">undef</span>,
        <span class="synString">reader</span>   =&gt; { <span class="synString">_class_name</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Instance::</span><span class="synIdentifier">_class_name</span> },
        <span class="synComment">#lazy     =&gt; 1, # not yet supported by Class::MOP but out our version does it anyway</span>
        <span class="synComment">#default  =&gt; sub { $_[0]-&gt;associated_metaclass-&gt;name },</span>
        _definition_context(),
    ),
);

Class::MOP::Instance-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'attributes'</span>,
        <span class="synString">reader</span>   =&gt; { <span class="synString">attributes</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Instance::</span><span class="synIdentifier">get_all_attributes</span> },
        _definition_context(),
    ),
);

Class::MOP::Instance-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'slots'</span>,
        <span class="synString">reader</span>   =&gt; { <span class="synString">slots</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Instance::</span><span class="synIdentifier">slots</span> },
        _definition_context(),
    ),
);

Class::MOP::Instance-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'slot_hash'</span>,
        <span class="synString">reader</span>   =&gt; { <span class="synString">slot_hash</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Instance::</span><span class="synIdentifier">slot_hash</span> },
        _definition_context(),
    ),
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Object</span>

<span class="synComment"># need to replace the meta method there with a real meta method object</span>
Class::MOP::Object-&gt;meta-&gt;_add_meta_method(<span class="synString">'meta'</span>);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Mixin</span>

<span class="synComment"># need to replace the meta method there with a real meta method object</span>
Class::MOP::Mixin-&gt;meta-&gt;_add_meta_method(<span class="synString">'meta'</span>);

<span class="synStatement">require</span> Class::MOP::Deprecated <span class="synConditional">unless</span> <span class="synStatement">our</span> <span class="synIdentifier">$no_deprecated</span>;

<span class="synComment"># we need the meta instance of the meta instance to be created now, in order</span>
<span class="synComment"># for the constructor to be able to use it</span>
Class::MOP::Instance-&gt;meta-&gt;get_meta_instance;

<span class="synComment"># pretend the add_method never happened. it hasn't yet affected anything</span>
<span class="synOperator">undef</span> Class::MOP::Instance-&gt;meta-&gt;{_package_cache_flag};

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Now close all the Class::MOP::* classes</span>

<span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we don't need to inline the accessors this only lengthens the compile</span>
<span class="synComment"># time of the MOP, and gives us no actual benefits.</span>

<span class="synIdentifier">$_-&gt;meta-&gt;make_immutable</span>(
    <span class="synString">inline_constructor</span>  =&gt; <span class="synNumber">0</span>,
    <span class="synString">constructor_name</span>    =&gt; <span class="synString">&quot;_new&quot;</span>,
    <span class="synString">inline_accessors</span> =&gt; <span class="synNumber">0</span>,
) <span class="synRepeat">for</span> <span class="synString">qw/</span>
<span class="synString">    Class::MOP::Package</span>
<span class="synString">    Class::MOP::Module</span>
<span class="synString">    Class::MOP::Class</span>

<span class="synString">    Class::MOP::Attribute</span>
<span class="synString">    Class::MOP::Method</span>
<span class="synString">    Class::MOP::Instance</span>

<span class="synString">    Class::MOP::Object</span>

<span class="synString">    Class::MOP::Method::Generated</span>
<span class="synString">    Class::MOP::Method::Inlined</span>

<span class="synString">    Class::MOP::Method::Accessor</span>
<span class="synString">    Class::MOP::Method::Constructor</span>
<span class="synString">    Class::MOP::Method::Wrapped</span>

<span class="synString">    Class::MOP::Method::Meta</span>
<span class="synString">    Class::MOP::Method::Overload</span>
<span class="synString">/</span>;

<span class="synIdentifier">$_-&gt;meta-&gt;make_immutable</span>(
    <span class="synString">inline_constructor</span>  =&gt; <span class="synNumber">0</span>,
    <span class="synString">constructor_name</span>    =&gt; <span class="synOperator">undef</span>,
    <span class="synString">inline_accessors</span> =&gt; <span class="synNumber">0</span>,
) <span class="synRepeat">for</span> <span class="synString">qw/</span>
<span class="synString">    Class::MOP::Mixin</span>
<span class="synString">    Class::MOP::Mixin::AttributeCore</span>
<span class="synString">    Class::MOP::Mixin::HasAttributes</span>
<span class="synString">    Class::MOP::Mixin::HasMethods</span>
<span class="synString">/</span>;

<span class="synNumber">1</span>;

<span class="synComment"># ABSTRACT: A Meta Object Protocol for Perl 5</span>

<span class="synComment">__END__</span>

<span class="synStatement">=pod</span>

<span class="synStatement">=head1</span><span class="synString"> NAME</span>

Class::MOP - A Meta Object Protocol for Perl 5

<span class="synStatement">=head1</span><span class="synString"> VERSION</span>

version 2.1005

<span class="synStatement">=head1</span><span class="synString"> DESCRIPTION</span>

This module is a fully functioning meta object protocol for the
Perl 5 object system. It makes no attempt to change the behavior or
characteristics of the Perl 5 object system, only to create a
protocol for its manipulation and introspection.

That said, it does attempt to create the tools for building a rich set
of extensions to the Perl 5 object system. Every attempt has been made
to abide by the spirit of the Perl 5 object system that we all know
and love.

This documentation is sparse on conceptual details. We suggest looking
at the items listed in the <span class="synIdentifier">L&lt;SEE ALSO&gt;</span> section for more
information. In particular the book &quot;The Art of the Meta Object
Protocol&quot; was very influential in the development of this system.

<span class="synStatement">=head2</span><span class="synString"> What is a Meta Object Protocol?</span>

A meta object protocol is an API to an object system.

To be more specific, it abstracts the components of an object system
(classes, object, methods, object attributes, etc.). These
abstractions can then be used to inspect and manipulate the object
system which they describe.

It can be said that there are two MOPs for any object system; the
implicit MOP and the explicit MOP. The implicit MOP handles things
like method dispatch or inheritance, which happen automatically as
part of how the object system works. The explicit MOP typically
handles the introspection/reflection features of the object system.

All object systems have implicit MOPs. Without one, they would not
work. Explicit MOPs are much less common, and depending on the
language can vary from restrictive (Reflection in Java or C#) to wide
open (CLOS is a perfect example).

<span class="synStatement">=head2</span><span class="synString"> Yet Another Class Builder! Why?</span>

This is <span class="synIdentifier">B&lt;not&gt;</span> a class builder so much as a I&lt;class builder
<span class="synIdentifier">B&lt;builder&gt;</span>&gt;. The intent is that an end user will not use this module
directly, but instead this module is used by module authors to build
extensions and features onto the Perl 5 object system.

This system is used by <span class="synIdentifier">L&lt;Moose&gt;</span>, which supplies a powerful class
builder system built entirely on top of <span class="synIdentifier">C&lt;Class::MOP&gt;</span>.

<span class="synStatement">=head2</span><span class="synString"> Who is this module for?</span>

This module is for anyone who has ever created or wanted to create a
module for the Class:: namespace. The tools which this module provides
make doing complex Perl 5 wizardry simpler, by removing such barriers
as the need to hack symbol tables, or understand the fine details of
method dispatch.

<span class="synStatement">=head2</span><span class="synString"> What changes do I have to make to use this module?</span>

This module was designed to be as unobtrusive as possible. Many of its
features are accessible without <span class="synIdentifier">B&lt;any&gt;</span> change to your existing
code. It is meant to be a complement to your existing code and not an
intrusion on your code base. Unlike many other <span class="synIdentifier">B&lt;Class::&gt;</span> modules,
this module <span class="synIdentifier">B&lt;does not&gt;</span> require you subclass it, or even that you
<span class="synIdentifier">C&lt;use&gt;</span> it in within your module's package.

The only features which require additions to your code are the
attribute handling and instance construction features, and these are
both completely optional features. The only reason for this is because
Perl 5's object system does not actually have these features built
in. More information about this feature can be found below.

<span class="synStatement">=head2</span><span class="synString"> About Performance</span>

It is a common misconception that explicit MOPs are a performance hit.
This is not a universal truth, it is a side-effect of some specific
implementations. For instance, using Java reflection is slow because
the JVM cannot take advantage of any compiler optimizations, and the
JVM has to deal with much more runtime type information as well.

Reflection in C# is marginally better as it was designed into the
language and runtime (the CLR). In contrast, CLOS (the Common Lisp
Object System) was built to support an explicit MOP, and so
performance is tuned for it.

This library in particular does its absolute best to avoid putting
<span class="synIdentifier">B&lt;any&gt;</span> drain at all upon your code's performance. In fact, by itself
it does nothing to affect your existing code. So you only pay for what
you actually use.

<span class="synStatement">=head2</span><span class="synString"> About Metaclass compatibility</span>

This module makes sure that all metaclasses created are both upwards
and downwards compatible. The topic of metaclass compatibility is
highly esoteric and is something only encountered when doing deep and
involved metaclass hacking. There are two basic kinds of metaclass
incompatibility; upwards and downwards.

Upwards metaclass compatibility means that the metaclass of a
given class is either the same as (or a subclass of) all of the
class's ancestors.

Downward metaclass compatibility means that the metaclasses of a
given class's ancestors are all the same as (or a subclass of) that
metaclass.

Here is a diagram showing a set of two classes (<span class="synIdentifier">C&lt;A&gt;</span> and <span class="synIdentifier">C&lt;B&gt;</span>) and
two metaclasses (<span class="synIdentifier">C&lt;Meta::A&gt;</span> and <span class="synIdentifier">C&lt;Meta::B&gt;</span>) which have correct
metaclass compatibility both upwards and downwards.

<span class="synPreProc">    +---------+     +---------+</span>
<span class="synPreProc">    | Meta::A |&lt;----| Meta::B |      &lt;....... (instance of  )</span>
<span class="synPreProc">    +---------+     +---------+      &lt;------- (inherits from)</span>
<span class="synPreProc">         ^               ^</span>
<span class="synPreProc">         :               :</span>
<span class="synPreProc">    +---------+     +---------+</span>
<span class="synPreProc">    |    A    |&lt;----|    B    |</span>
<span class="synPreProc">    +---------+     +---------+</span>

In actuality, <span class="synIdentifier">I&lt;all&gt;</span> of a class's metaclasses must be compatible,
not just the class metaclass. That includes the instance, attribute,
and method metaclasses, as well as the constructor and destructor
classes.

<span class="synIdentifier">C&lt;Class::MOP&gt;</span> will attempt to fix some simple types of
incompatibilities. If all the metaclasses for the parent class are
<span class="synIdentifier">I&lt;subclasses&gt;</span> of the child's metaclasses then we can simply replace
the child's metaclasses with the parent's. In addition, if the child
is missing a metaclass that the parent has, we can also just make the
child use the parent's metaclass.

As I said this is a highly esoteric topic and one you will only run
into if you do a lot of subclassing of <span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span>. If you
are interested in why this is an issue see the paper I&lt;Uniform and
safe metaclass composition&gt; linked to in the <span class="synIdentifier">L&lt;SEE ALSO&gt;</span> section of
this document.

<span class="synStatement">=head2</span><span class="synString"> Using custom metaclasses</span>

Always use the <span class="synIdentifier">L&lt;metaclass&gt;</span> pragma when using a custom metaclass, this
will ensure the proper initialization order and not accidentally
create an incorrect type of metaclass for you. This is a very rare
problem, and one which can only occur if you are doing deep metaclass
programming. So in other words, don't worry about it.

Note that if you're using <span class="synIdentifier">L&lt;Moose&gt;</span> we encourage you to <span class="synIdentifier">I&lt;not&gt;</span> use the
<span class="synIdentifier">L&lt;metaclass&gt;</span> pragma, and instead use <span class="synIdentifier">L&lt;Moose::Util::MetaRole&gt;</span> to apply
roles to a class's metaclasses. This topic is covered at length in
various <span class="synIdentifier">L&lt;Moose::Cookbook&gt;</span> recipes.

<span class="synStatement">=head1</span><span class="synString"> PROTOCOLS</span>

The meta-object protocol is divided into 4 main sub-protocols:

<span class="synStatement">=head2</span><span class="synString"> The Class protocol</span>

This provides a means of manipulating and introspecting a Perl 5
class. It handles symbol table hacking for you, and provides a rich
set of methods that go beyond simple package introspection.

See <span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span> for more details.

<span class="synStatement">=head2</span><span class="synString"> The Attribute protocol</span>

This provides a consistent representation for an attribute of a Perl 5
class. Since there are so many ways to create and handle attributes in
Perl 5 OO, the Attribute protocol provide as much of a unified
approach as possible. Of course, you are always free to extend this
protocol by subclassing the appropriate classes.

See <span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span> for more details.

<span class="synStatement">=head2</span><span class="synString"> The Method protocol</span>

This provides a means of manipulating and introspecting methods in the
Perl 5 object system. As with attributes, there are many ways to
approach this topic, so we try to keep it pretty basic, while still
making it possible to extend the system in many ways.

See <span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span> for more details.

<span class="synStatement">=head2</span><span class="synString"> The Instance protocol</span>

This provides a layer of abstraction for creating object instances.
Since the other layers use this protocol, it is relatively easy to
change the type of your instances from the default hash reference to
some other type of reference. Several examples are provided in the
<span class="synIdentifier">F&lt;examples/&gt;</span> directory included in this distribution.

See <span class="synIdentifier">L&lt;Class::MOP::Instance&gt;</span> for more details.

<span class="synStatement">=head1</span><span class="synString"> FUNCTIONS</span>

Note that this module does not export any constants or functions.

<span class="synStatement">=head2</span><span class="synString"> Utility functions</span>

Note that these are all called as <span class="synIdentifier">B&lt;functions, not methods&gt;</span>.

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::get_code_info($code)&gt;</span>

This function returns two values, the name of the package the <span class="synIdentifier">C&lt;$code&gt;</span>
is from and the name of the <span class="synIdentifier">C&lt;$code&gt;</span> itself. This is used by several
elements of the MOP to determine where a given <span class="synIdentifier">C&lt;$code&gt;</span> reference is
from.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::class_of($instance_or_class_name)&gt;</span>

This will return the metaclass of the given instance or class name.  If the
class lacks a metaclass, no metaclass will be initialized, and <span class="synIdentifier">C&lt;undef&gt;</span> will be
returned.

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Metaclass cache functions</span>

<span class="synIdentifier">C&lt;Class::MOP&gt;</span> holds a cache of metaclasses. The following are functions
(<span class="synIdentifier">B&lt;not methods&gt;</span>) which can be used to access that cache. It is not
recommended that you mess with these. Bad things could happen, but if
you are brave and willing to risk it: go for it!

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::get_all_metaclasses&gt;</span>

This will return a hash of all the metaclass instances that have
been cached by <span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span>, keyed by the package name.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::get_all_metaclass_instances&gt;</span>

This will return a list of all the metaclass instances that have
been cached by <span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span>.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::get_all_metaclass_names&gt;</span>

This will return a list of all the metaclass names that have
been cached by <span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span>.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::get_metaclass_by_name($name)&gt;</span>

This will return a cached <span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span> instance, or nothing
if no metaclass exists with that <span class="synIdentifier">C&lt;$name&gt;</span>.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::store_metaclass_by_name($name, $meta)&gt;</span>

This will store a metaclass in the cache at the supplied <span class="synIdentifier">C&lt;$key&gt;</span>.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::weaken_metaclass($name)&gt;</span>

In rare cases (e.g. anonymous metaclasses) it is desirable to
store a weakened reference in the metaclass cache. This
function will weaken the reference to the metaclass stored
in <span class="synIdentifier">C&lt;$name&gt;</span>.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::metaclass_is_weak($name)&gt;</span>

Returns true if the metaclass for <span class="synIdentifier">C&lt;$name&gt;</span> has been weakened
(via <span class="synIdentifier">C&lt;weaken_metaclass&gt;</span>).

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::does_metaclass_exist($name)&gt;</span>

This will return true of there exists a metaclass stored in the
<span class="synIdentifier">C&lt;$name&gt;</span> key, and return false otherwise.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::remove_metaclass_by_name($name)&gt;</span>

This will remove the metaclass stored in the <span class="synIdentifier">C&lt;$name&gt;</span> key.

<span class="synStatement">=back</span>

Some utility functions (such as <span class="synIdentifier">C&lt;Class::MOP::load_class&gt;</span>) that were
previously defined in <span class="synIdentifier">C&lt;Class::MOP&gt;</span> regarding loading of classes have been
extracted to <span class="synIdentifier">L&lt;Class::Load&gt;</span>. Please see <span class="synIdentifier">L&lt;Class::Load&gt;</span> for documentation.

<span class="synStatement">=head1</span><span class="synString"> SEE ALSO</span>

<span class="synStatement">=head2</span><span class="synString"> Books</span>

There are very few books out on Meta Object Protocols and Metaclasses
because it is such an esoteric topic. The following books are really
the only ones I have found. If you know of any more, <span class="synIdentifier">B&lt;I&lt;please&gt;&gt;</span>
email me and let me know, I would love to hear about them.

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;The Art of the Meta Object Protocol&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;Advances in Object-Oriented Metalevel Architecture and Reflection&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;Putting MetaClasses to Work&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;Smalltalk: The Language&gt;</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Papers</span>

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> &quot;Uniform and safe metaclass composition&quot;</span>

An excellent paper by the people who brought us the original Traits paper.
This paper is on how Traits can be used to do safe metaclass composition,
and offers an excellent introduction section which delves into the topic of
metaclass compatibility.

<span class="synIdentifier">L&lt;http://scg.unibe.ch/archive/papers/Duca05ySafeMetaclassTrait.pdf&gt;</span>

<span class="synStatement">=item</span><span class="synString"> &quot;Safe Metaclass Programming&quot;</span>

This paper seems to precede the above paper, and propose a mix-in based
approach as opposed to the Traits based approach. Both papers have similar
information on the metaclass compatibility problem space.

<span class="synIdentifier">L&lt;http://citeseer.ist.psu.edu/37617.html&gt;</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Prior Art</span>

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> The Perl 6 MetaModel work in the Pugs project</span>

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">L&lt;http://svn.openfoundry.org/pugs/misc/Perl-MetaModel/&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">L&lt;http://github.com/perl6/p5-modules/tree/master/Perl6-ObjectSpace/&gt;</span>

<span class="synStatement">=back</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Articles</span>

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> CPAN Module Review of Class::MOP</span>

<span class="synIdentifier">L&lt;http://www.oreillynet.com/onlamp/blog/2006/06/cpan_module_review_classmop.html&gt;</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> SIMILAR MODULES</span>

As I have said above, this module is a class-builder-builder, so it is
not the same thing as modules like <span class="synIdentifier">L&lt;Class::Accessor&gt;</span> and
<span class="synIdentifier">L&lt;Class::MethodMaker&gt;</span>. That being said there are very few modules on CPAN
with similar goals to this module. The one I have found which is most
like this module is <span class="synIdentifier">L&lt;Class::Meta&gt;</span>, although its philosophy and the MOP it
creates are very different from this modules.

<span class="synStatement">=head1</span><span class="synString"> BUGS</span>

All complex software has bugs lurking in it, and this module is no
exception.

Please report any bugs to <span class="synIdentifier">C&lt;bug-class-mop@rt.cpan.org&gt;</span>, or through the
web interface at <span class="synIdentifier">L&lt;http://rt.cpan.org&gt;</span>.

You can also discuss feature requests or possible bugs on the Moose
mailing list (moose<span class="synIdentifier">@perl</span>.org) or on IRC at
<span class="synIdentifier">L&lt;irc://irc.perl.org/#moose&gt;</span>.

<span class="synStatement">=head1</span><span class="synString"> ACKNOWLEDGEMENTS</span>

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> Rob Kinyon</span>

Thanks to Rob for actually getting the development of this module kick-started.

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> AUTHOR</span>

Moose is maintained by the Moose Cabal, along with the help of many contributors. See <span class="synIdentifier">L&lt;Moose/CABAL&gt;</span> and <span class="synIdentifier">L&lt;Moose/CONTRIBUTORS&gt;</span> for details.

<span class="synStatement">=head1</span><span class="synString"> COPYRIGHT AND LICENSE</span>

This software is copyright (c) 2013 by Infinity Interactive, Inc..

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

<span class="synStatement">=cut</span>
</pre>

 </body>
</html>
