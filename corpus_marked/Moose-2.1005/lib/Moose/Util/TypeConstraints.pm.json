[["","\n"],["Statement","package"],["Type"," Moose::Util::TypeConstraints"],["",";\n"],["PreProc","BEGIN "],["","{\n  "],["Identifier","$"],["Type","Moose::Util::TypeConstraints::"],["Identifier","AUTHORITY"],[""," = "],["String","'cpan:STEVAN'"],["",";\n}\n{\n  "],["Identifier","$"],["Type","Moose::Util::TypeConstraints::"],["Identifier","VERSION"],[""," = "],["String","'2.1005'"],["",";\n}\n\n"],["Statement","use "],["","Carp ();\n"],["Statement","use "],["","List::MoreUtils "],["String","qw( all any )"],["",";\n"],["Statement","use "],["","Scalar::Util "],["String","qw( blessed reftype )"],["",";\n"],["Statement","use "],["","Moose::Exporter;\n\n"],["Comment","## --------------------------------------------------------"],["","\n"],["Comment","# Prototyped subs must be predeclared because we have a"],["","\n"],["Comment","# circular dependency with Moose::Meta::Attribute et. al."],["","\n"],["Comment","# so in case of us being use'd first the predeclaration"],["","\n"],["Comment","# ensures the prototypes are in scope when consumers are"],["","\n"],["Comment","# compiled."],["","\n\n"],["Comment","# dah sugah!"],["","\n"],["Keyword","sub "],["Function","where "],["Type","(&)"],["",";\n"],["Keyword","sub "],["Function","via "],["Type","(&)"],["",";\n"],["Keyword","sub "],["Function","message "],["Type","(&)"],["",";\n"],["Keyword","sub "],["Function","optimize_as "],["Type","(&)"],["",";\n"],["Keyword","sub "],["Function","inline_as "],["Type","(&)"],["",";\n\n"],["Comment","## --------------------------------------------------------"],["","\n\n"],["Statement","use "],["","Moose::Deprecated;\n"],["Statement","use "],["","Moose::Meta::TypeConstraint;\n"],["Statement","use "],["","Moose::Meta::TypeConstraint::Union;\n"],["Statement","use "],["","Moose::Meta::TypeConstraint::Parameterized;\n"],["Statement","use "],["","Moose::Meta::TypeConstraint::Parameterizable;\n"],["Statement","use "],["","Moose::Meta::TypeConstraint::Class;\n"],["Statement","use "],["","Moose::Meta::TypeConstraint::Role;\n"],["Statement","use "],["","Moose::Meta::TypeConstraint::Enum;\n"],["Statement","use "],["","Moose::Meta::TypeConstraint::DuckType;\n"],["Statement","use "],["","Moose::Meta::TypeCoercion;\n"],["Statement","use "],["","Moose::Meta::TypeCoercion::Union;\n"],["Statement","use "],["","Moose::Meta::TypeConstraint::Registry;\n\nMoose::Exporter->setup_import_methods(\n    "],["String","as_is"],[""," => [\n        "],["String","qw("],["","\n"],["String","            type subtype class_type role_type maybe_type duck_type"],["","\n"],["String","            as where message optimize_as inline_as"],["","\n"],["String","            coerce from via"],["","\n"],["String","            enum union"],["","\n"],["String","            find_type_constraint"],["","\n"],["String","            register_type_constraint"],["","\n"],["String","            match_on_type )"],["","\n    ],\n);\n\n"],["Comment","## --------------------------------------------------------"],["","\n"],["Comment","## type registry and some useful functions for it"],["","\n"],["Comment","## --------------------------------------------------------"],["","\n\n"],["Statement","my"],[""," "],["Identifier","$REGISTRY"],[""," = Moose::Meta::TypeConstraint::Registry->new;\n\n"],["Keyword","sub "],["Function","get_type_constraint_registry "],["","{"],["Identifier","$REGISTRY"],["","}\n"],["Keyword","sub "],["Function","list_all_type_constraints    "],["","{ "],["Statement","keys"],[""," "],["Identifier","%{"],[""," "],["Identifier","$REGISTRY"],["","->type_constraints "],["Identifier","}"],[""," }\n\n"],["Keyword","sub "],["Function","export_type_constraints_as_functions "],["","{\n    "],["Statement","my"],[""," "],["Identifier","$pkg"],[""," = "],["Statement","caller"],["","();\n    "],["Statement","no strict"],[""," "],["String","'refs'"],["",";\n    "],["Repeat","foreach"],[""," "],["Statement","my"],[""," "],["Identifier","$constraint"],[""," ( "],["Statement","keys"],[""," "],["Identifier","%{"],[""," "],["Identifier","$REGISTRY"],["","->type_constraints "],["Identifier","}"],[""," ) {\n        "],["Statement","my"],[""," "],["Identifier","$tc"],[""," = "],["Identifier","$REGISTRY"],["","->get_type_constraint("],["Identifier","$constraint"],["",")\n            ->_compiled_type_constraint;\n        "],["Identifier","*{"],["String","\""],["Identifier","${pkg}"],["String","::"],["Identifier","${constraint}"],["String","\""],["Identifier","}"],["","\n            = "],["Keyword","sub "],["","{ "],["Identifier","$tc"],["","->( "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," ) ? "],["Number","1"],[""," : "],["Operator","undef"],[""," };    "],["Comment","# the undef is for compat"],["","\n    }\n}\n\n"],["Keyword","sub "],["Function","create_type_constraint_union "],["","{\n    _create_type_constraint_union(\\"],["Identifier","@_"],["",");\n}\n\n"],["Keyword","sub "],["Function","create_named_type_constraint_union "],["","{\n    "],["Statement","my"],[""," "],["Identifier","$name"],[""," = "],["Statement","shift"],["",";\n    _create_type_constraint_union("],["Identifier","$name"],["",", \\"],["Identifier","@_"],["",");\n}\n\n"],["Keyword","sub "],["Function","_create_type_constraint_union "],["","{\n    "],["Statement","my"],[""," "],["Identifier","$name"],["",";\n    "],["Identifier","$name"],[""," = "],["Statement","shift"],[""," "],["Conditional","if"],[""," "],["Identifier","@_"],[""," > "],["Number","1"],["",";\n    "],["Statement","my"],[""," "],["Identifier","@tcs"],[""," = "],["Identifier","@{"],[""," "],["Statement","shift"],["","() "],["Identifier","}"],["",";\n\n    "],["Statement","my"],[""," "],["Identifier","@type_constraint_names"],["",";\n\n    "],["Conditional","if"],[""," ( "],["Statement","scalar"],[""," "],["Identifier","@tcs"],[""," == "],["Number","1"],[""," && _detect_type_constraint_union( "],["Identifier","$tcs["],["Number","0"],["Identifier","]"],[""," ) ) {\n        "],["Identifier","@type_constraint_names"],[""," = _parse_type_constraint_union( "],["Identifier","$tcs["],["Number","0"],["Identifier","]"],[""," );\n    }\n    "],["Conditional","else"],[""," {\n        "],["Identifier","@type_constraint_names"],[""," = "],["Identifier","@tcs"],["",";\n    }\n\n    ( "],["Statement","scalar"],[""," "],["Identifier","@type_constraint_names"],[""," >= "],["Number","2"],[""," )\n        || __PACKAGE__->_throw_error(\n        "],["String","\"You must pass in at least 2 type names to make a union\""],["",");\n\n    "],["Statement","my"],[""," "],["Identifier","@type_constraints"],[""," = "],["Statement","map"],[""," "],["Statement","{"],["","\n        find_or_parse_type_constraint("],["Identifier","$_"],["",")\n            || __PACKAGE__->_throw_error(\n            "],["String","\"Could not locate type constraint ("],["Identifier","$_"],["String",") for the union\""],["",");\n    "],["Statement","}"],[""," "],["Identifier","@type_constraint_names"],["",";\n\n    "],["Statement","my"],[""," "],["Identifier","%options"],[""," = (\n      "],["String","type_constraints"],[""," => \\"],["Identifier","@type_constraints"],["","\n    );\n    "],["Identifier","$options{"],["String","name"],["Identifier","}"],[""," = "],["Identifier","$name"],[""," "],["Conditional","if"],[""," "],["Operator","defined"],[""," "],["Identifier","$name"],["",";\n\n    "],["Statement","return"],[""," Moose::Meta::TypeConstraint::Union->new("],["Identifier","%options"],["",");\n}\n\n\n"],["Keyword","sub "],["Function","create_parameterized_type_constraint "],["","{\n    "],["Statement","my"],[""," "],["Identifier","$type_constraint_name"],[""," = "],["Statement","shift"],["",";\n    "],["Statement","my"],[""," ( "],["Identifier","$base_type"],["",", "],["Identifier","$type_parameter"],[""," )\n        = _parse_parameterized_type_constraint("],["Identifier","$type_constraint_name"],["",");\n\n    ( "],["Operator","defined"],[""," "],["Identifier","$base_type"],[""," && "],["Operator","defined"],[""," "],["Identifier","$type_parameter"],[""," )\n        || __PACKAGE__->_throw_error(\n        "],["String","\"Could not parse type name ("],["Identifier","$type_constraint_name"],["String",") correctly\""],["",");\n\n    "],["Conditional","if"],[""," ( "],["Identifier","$REGISTRY"],["","->has_type_constraint("],["Identifier","$base_type"],["",") ) {\n        "],["Statement","my"],[""," "],["Identifier","$base_type_tc"],[""," = "],["Identifier","$REGISTRY"],["","->get_type_constraint("],["Identifier","$base_type"],["",");\n        "],["Statement","return"],[""," _create_parameterized_type_constraint(\n            "],["Identifier","$base_type_tc"],["",",\n            "],["Identifier","$type_parameter"],["","\n        );\n    }\n    "],["Conditional","else"],[""," {\n        __PACKAGE__->_throw_error(\n            "],["String","\"Could not locate the base type ("],["Identifier","$base_type"],["String",")\""],["",");\n    }\n}\n\n"],["Keyword","sub "],["Function","_create_parameterized_type_constraint "],["","{\n    "],["Statement","my"],[""," ( "],["Identifier","$base_type_tc"],["",", "],["Identifier","$type_parameter"],[""," ) = "],["Identifier","@_"],["",";\n    "],["Conditional","if"],[""," ( "],["Identifier","$base_type_tc"],["","->can("],["String","'parameterize'"],["",") ) {\n        "],["Statement","return"],[""," "],["Identifier","$base_type_tc"],["","->parameterize("],["Identifier","$type_parameter"],["",");\n    }\n    "],["Conditional","else"],[""," {\n        "],["Statement","return"],[""," Moose::Meta::TypeConstraint::Parameterized->new(\n            "],["String","name"],["","   => "],["Identifier","$base_type_tc"],["","->name . "],["String","'['"],[""," . "],["Identifier","$type_parameter"],[""," . "],["String","']'"],["",",\n            "],["String","parent"],[""," => "],["Identifier","$base_type_tc"],["",",\n            "],["String","type_parameter"],[""," =>\n                find_or_create_isa_type_constraint("],["Identifier","$type_parameter"],["","),\n        );\n    }\n}\n\n"],["Comment","#should we also support optimized checks?"],["","\n"],["Keyword","sub "],["Function","create_class_type_constraint "],["","{\n    "],["Statement","my"],[""," ( "],["Identifier","$class"],["",", "],["Identifier","$options"],[""," ) = "],["Identifier","@_"],["",";\n\n"],["Comment","# too early for this check"],["","\n"],["Comment","#find_type_constraint(\"ClassName\")->check($class)"],["","\n"],["Comment","#    || __PACKAGE__->_throw_error(\"Can't create a class type constraint because '$class' is not a class name\");"],["","\n\n    "],["Statement","my"],[""," "],["Identifier","$pkg_defined_in"],[""," = "],["Identifier","$options->{"],["String","package_defined_in"],["Identifier","}"],[""," || "],["Statement","scalar"],["","( "],["Statement","caller"],["","("],["Number","1"],["",") );\n\n    "],["Conditional","if"],[""," ("],["Statement","my"],[""," "],["Identifier","$type"],[""," = "],["Identifier","$REGISTRY"],["","->get_type_constraint("],["Identifier","$class"],["",")) {\n        "],["Conditional","if"],[""," (!("],["Identifier","$type"],["","->isa("],["String","'Moose::Meta::TypeConstraint::Class'"],["",") && "],["Identifier","$type"],["","->class "],["Operator","eq"],[""," "],["Identifier","$class"],["",")) {\n            _confess(\n                "],["String","\"The type constraint '"],["Identifier","$class"],["String","' has already been created in \""],["","\n              . "],["Identifier","$type"],["","->_package_defined_in\n              . "],["String","\" and cannot be created again in \""],["","\n              . "],["Identifier","$pkg_defined_in"],[""," )\n        }\n        "],["Conditional","else"],[""," {\n            "],["Statement","return"],[""," "],["Identifier","$type"],["",";\n        }\n    }\n\n    "],["Statement","my"],[""," "],["Identifier","%options"],[""," = (\n        "],["String","class"],["","              => "],["Identifier","$class"],["",",\n        "],["String","name"],["","               => "],["Identifier","$class"],["",",\n        "],["String","package_defined_in"],[""," => "],["Identifier","$pkg_defined_in"],["",",\n        "],["Identifier","%{"],[""," "],["Identifier","$options"],[""," || {} "],["Identifier","}"],["",",\n    );\n\n    "],["Identifier","$options{"],["String","name"],["Identifier","}"],[""," ||= "],["String","\"__ANON__\""],["",";\n\n    "],["Statement","my"],[""," "],["Identifier","$tc"],[""," = Moose::Meta::TypeConstraint::Class->new("],["Identifier","%options"],["",");\n    "],["Identifier","$REGISTRY"],["","->add_type_constraint("],["Identifier","$tc"],["",");\n    "],["Statement","return"],[""," "],["Identifier","$tc"],["",";\n}\n\n"],["Keyword","sub "],["Function","create_role_type_constraint "],["","{\n    "],["Statement","my"],[""," ( "],["Identifier","$role"],["",", "],["Identifier","$options"],[""," ) = "],["Identifier","@_"],["",";\n\n"],["Comment","# too early for this check"],["","\n"],["Comment","#find_type_constraint(\"ClassName\")->check($class)"],["","\n"],["Comment","#    || __PACKAGE__->_throw_error(\"Can't create a class type constraint because '$class' is not a class name\");"],["","\n\n    "],["Statement","my"],[""," "],["Identifier","$pkg_defined_in"],[""," = "],["Identifier","$options->{"],["String","package_defined_in"],["Identifier","}"],[""," || "],["Statement","scalar"],["","( "],["Statement","caller"],["","("],["Number","1"],["",") );\n\n    "],["Conditional","if"],[""," ("],["Statement","my"],[""," "],["Identifier","$type"],[""," = "],["Identifier","$REGISTRY"],["","->get_type_constraint("],["Identifier","$role"],["",")) {\n        "],["Conditional","if"],[""," (!("],["Identifier","$type"],["","->isa("],["String","'Moose::Meta::TypeConstraint::Role'"],["",") && "],["Identifier","$type"],["","->role "],["Operator","eq"],[""," "],["Identifier","$role"],["",")) {\n            _confess(\n                "],["String","\"The type constraint '"],["Identifier","$role"],["String","' has already been created in \""],["","\n              . "],["Identifier","$type"],["","->_package_defined_in\n              . "],["String","\" and cannot be created again in \""],["","\n              . "],["Identifier","$pkg_defined_in"],[""," )\n        }\n        "],["Conditional","else"],[""," {\n            "],["Statement","return"],[""," "],["Identifier","$type"],["",";\n        }\n    }\n\n    "],["Statement","my"],[""," "],["Identifier","%options"],[""," = (\n        "],["String","role"],["","               => "],["Identifier","$role"],["",",\n        "],["String","name"],["","               => "],["Identifier","$role"],["",",\n        "],["String","package_defined_in"],[""," => "],["Identifier","$pkg_defined_in"],["",",\n        "],["Identifier","%{"],[""," "],["Identifier","$options"],[""," || {} "],["Identifier","}"],["",",\n    );\n\n    "],["Identifier","$options{"],["String","name"],["Identifier","}"],[""," ||= "],["String","\"__ANON__\""],["",";\n\n    "],["Statement","my"],[""," "],["Identifier","$tc"],[""," = Moose::Meta::TypeConstraint::Role->new("],["Identifier","%options"],["",");\n    "],["Identifier","$REGISTRY"],["","->add_type_constraint("],["Identifier","$tc"],["",");\n    "],["Statement","return"],[""," "],["Identifier","$tc"],["",";\n}\n\n"],["Keyword","sub "],["Function","find_or_create_type_constraint "],["","{\n    "],["Statement","my"],[""," ( "],["Identifier","$type_constraint_name"],["",", "],["Identifier","$options_for_anon_type"],[""," ) = "],["Identifier","@_"],["",";\n\n    "],["Conditional","if"],[""," ( "],["Statement","my"],[""," "],["Identifier","$constraint"],["","\n        = find_or_parse_type_constraint("],["Identifier","$type_constraint_name"],["",") ) {\n        "],["Statement","return"],[""," "],["Identifier","$constraint"],["",";\n    }\n    "],["Conditional","elsif"],[""," ( "],["Operator","defined"],[""," "],["Identifier","$options_for_anon_type"],[""," ) {\n\n        "],["Comment","# "],["Todo","NOTE:"],["","\n        "],["Comment","# if there is no $options_for_anon_type"],["","\n        "],["Comment","# specified, then we assume they don't"],["","\n        "],["Comment","# want to create one, and return nothing."],["","\n\n        "],["Comment","# otherwise assume that we should create"],["","\n        "],["Comment","# an ANON type with the $options_for_anon_type"],["","\n        "],["Comment","# options which can be passed in. It should"],["","\n        "],["Comment","# be noted that these don't get registered"],["","\n        "],["Comment","# so we need to return it."],["","\n        "],["Comment","# - SL"],["","\n        "],["Statement","return"],[""," Moose::Meta::TypeConstraint->new(\n            "],["String","name"],[""," => "],["String","'__ANON__'"],["",",\n            "],["Identifier","%{$options_for_anon_type}"],["","\n        );\n    }\n\n    "],["Statement","return"],["",";\n}\n\n"],["Keyword","sub "],["Function","find_or_create_isa_type_constraint "],["","{\n    "],["Statement","my"],[""," ("],["Identifier","$type_constraint_name"],["",", "],["Identifier","$options"],["",") = "],["Identifier","@_"],["",";\n    find_or_parse_type_constraint("],["Identifier","$type_constraint_name"],["",")\n        || create_class_type_constraint("],["Identifier","$type_constraint_name"],["",", "],["Identifier","$options"],["",");\n}\n\n"],["Keyword","sub "],["Function","find_or_create_does_type_constraint "],["","{\n    "],["Statement","my"],[""," ("],["Identifier","$type_constraint_name"],["",", "],["Identifier","$options"],["",") = "],["Identifier","@_"],["",";\n    find_or_parse_type_constraint("],["Identifier","$type_constraint_name"],["",")\n        || create_role_type_constraint("],["Identifier","$type_constraint_name"],["",", "],["Identifier","$options"],["",");\n}\n\n"],["Keyword","sub "],["Function","find_or_parse_type_constraint "],["","{\n    "],["Statement","my"],[""," "],["Identifier","$type_constraint_name"],[""," = normalize_type_constraint_name("],["Statement","shift"],["",");\n    "],["Statement","my"],[""," "],["Identifier","$constraint"],["",";\n\n    "],["Conditional","if"],[""," ( "],["Identifier","$constraint"],[""," = find_type_constraint("],["Identifier","$type_constraint_name"],["",") ) {\n        "],["Statement","return"],[""," "],["Identifier","$constraint"],["",";\n    }\n    "],["Conditional","elsif"],[""," ( _detect_type_constraint_union("],["Identifier","$type_constraint_name"],["",") ) {\n        "],["Identifier","$constraint"],[""," = create_type_constraint_union("],["Identifier","$type_constraint_name"],["",");\n    }\n    "],["Conditional","elsif"],[""," ( _detect_parameterized_type_constraint("],["Identifier","$type_constraint_name"],["",") ) {\n        "],["Identifier","$constraint"],["","\n            = create_parameterized_type_constraint("],["Identifier","$type_constraint_name"],["",");\n    }\n    "],["Conditional","else"],[""," {\n        "],["Statement","return"],["",";\n    }\n\n    "],["Identifier","$REGISTRY"],["","->add_type_constraint("],["Identifier","$constraint"],["",");\n    "],["Statement","return"],[""," "],["Identifier","$constraint"],["",";\n}\n\n"],["Keyword","sub "],["Function","normalize_type_constraint_name "],["","{\n    "],["Statement","my"],[""," "],["Identifier","$type_constraint_name"],[""," = "],["Statement","shift"],["",";\n    "],["Identifier","$type_constraint_name"],[""," =~ "],["Statement","s/"],["Special","\\s"],["Statement","//g"],["",";\n    "],["Statement","return"],[""," "],["Identifier","$type_constraint_name"],["",";\n}\n\n"],["Keyword","sub "],["Function","_confess "],["","{\n    "],["Statement","my"],[""," "],["Identifier","$error"],[""," = "],["Statement","shift"],["",";\n\n    "],["Statement","local"],[""," "],["Identifier","$"],["Type","Carp::"],["Identifier","CarpLevel"],[""," = "],["Identifier","$"],["Type","Carp::"],["Identifier","CarpLevel"],[""," + "],["Number","1"],["",";\n    Carp::confess("],["Identifier","$error"],["",");\n}\n\n"],["Comment","## --------------------------------------------------------"],["","\n"],["Comment","## exported functions ..."],["","\n"],["Comment","## --------------------------------------------------------"],["","\n\n"],["Keyword","sub "],["Function","find_type_constraint "],["","{\n    "],["Statement","my"],[""," "],["Identifier","$type"],[""," = "],["Statement","shift"],["",";\n\n    "],["Conditional","if"],[""," ( blessed "],["Identifier","$type"],[""," "],["Operator","and"],[""," "],["Identifier","$type"],["","->isa("],["String","\"Moose::Meta::TypeConstraint\""],["",") ) {\n        "],["Statement","return"],[""," "],["Identifier","$type"],["",";\n    }\n    "],["Conditional","else"],[""," {\n        "],["Statement","return"],[""," "],["Conditional","unless"],[""," "],["Identifier","$REGISTRY"],["","->has_type_constraint("],["Identifier","$type"],["",");\n        "],["Statement","return"],[""," "],["Identifier","$REGISTRY"],["","->get_type_constraint("],["Identifier","$type"],["",");\n    }\n}\n\n"],["Keyword","sub "],["Function","register_type_constraint "],["","{\n    "],["Statement","my"],[""," "],["Identifier","$constraint"],[""," = "],["Statement","shift"],["",";\n    __PACKAGE__->_throw_error("],["String","\"can't register an unnamed type constraint\""],["",")\n        "],["Conditional","unless"],[""," "],["Operator","defined"],[""," "],["Identifier","$constraint"],["","->name;\n    "],["Identifier","$REGISTRY"],["","->add_type_constraint("],["Identifier","$constraint"],["",");\n    "],["Statement","return"],[""," "],["Identifier","$constraint"],["",";\n}\n\n"],["Comment","# type constructors"],["","\n\n"],["Keyword","sub "],["Function","type "],["","{\n    "],["Statement","my"],[""," "],["Identifier","$name"],[""," = "],["Statement","shift"],["",";\n\n    "],["Statement","my"],[""," "],["Identifier","%p"],[""," = "],["Statement","map"],[""," "],["Statement","{"],[""," "],["Identifier","%{$_}"],[""," "],["Statement","}"],[""," "],["Identifier","@_"],["",";\n\n    "],["Statement","return"],[""," _create_type_constraint(\n        "],["Identifier","$name"],["",", "],["Operator","undef"],["",", "],["Identifier","$p{"],["String","where"],["Identifier","}"],["",", "],["Identifier","$p{"],["String","message"],["Identifier","}"],["",",\n        "],["Identifier","$p{"],["String","optimize_as"],["Identifier","}"],["",", "],["Identifier","$p{"],["String","inline_as"],["Identifier","}"],["",",\n    );\n}\n\n"],["Keyword","sub "],["Function","subtype "],["","{\n    "],["Conditional","if"],[""," ( "],["Identifier","@_"],[""," == "],["Number","1"],[""," && !"],["Operator","ref"],[""," "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," ) {\n        __PACKAGE__->_throw_error(\n            "],["String","'A subtype cannot consist solely of a name, it must have a parent'"],["","\n        );\n    }\n\n    "],["Comment","# The blessed check is mostly to accommodate MooseX::Types, which"],["","\n    "],["Comment","# uses an object which overloads stringification as a type name."],["","\n    "],["Statement","my"],[""," "],["Identifier","$name"],[""," = "],["Operator","ref"],[""," "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," && !blessed "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," ? "],["Operator","undef"],[""," : "],["Statement","shift"],["",";\n\n    "],["Statement","my"],[""," "],["Identifier","%p"],[""," = "],["Statement","map"],[""," "],["Statement","{"],[""," "],["Identifier","%{$_}"],[""," "],["Statement","}"],[""," "],["Identifier","@_"],["",";\n\n    "],["Comment","# subtype Str => where { ... };"],["","\n    "],["Conditional","if"],[""," ( !"],["Statement","exists"],[""," "],["Identifier","$p{"],["String","as"],["Identifier","}"],[""," ) {\n        "],["Identifier","$p{"],["String","as"],["Identifier","}"],[""," = "],["Identifier","$name"],["",";\n        "],["Identifier","$name"],[""," = "],["Operator","undef"],["",";\n    }\n\n    "],["Statement","return"],[""," _create_type_constraint(\n        "],["Identifier","$name"],["",", "],["Identifier","$p{"],["String","as"],["Identifier","}"],["",", "],["Identifier","$p{"],["String","where"],["Identifier","}"],["",", "],["Identifier","$p{"],["String","message"],["Identifier","}"],["",",\n        "],["Identifier","$p{"],["String","optimize_as"],["Identifier","}"],["",", "],["Identifier","$p{"],["String","inline_as"],["Identifier","}"],["",",\n    );\n}\n\n"],["Keyword","sub "],["Function","class_type "],["","{\n    create_class_type_constraint("],["Identifier","@_"],["",");\n}\n\n"],["Keyword","sub "],["Function","role_type "],["Type","($;$)"],[""," {\n    create_role_type_constraint("],["Identifier","@_"],["",");\n}\n\n"],["Keyword","sub "],["Function","maybe_type "],["","{\n    "],["Statement","my"],[""," ("],["Identifier","$type_parameter"],["",") = "],["Identifier","@_"],["",";\n\n    register_type_constraint(\n        "],["Identifier","$REGISTRY"],["","->get_type_constraint("],["String","'Maybe'"],["",")->parameterize("],["Identifier","$type_parameter"],["",")\n    );\n}\n\n"],["Keyword","sub "],["Function","duck_type "],["","{\n    "],["Statement","my"],[""," ( "],["Identifier","$type_name"],["",", "],["Identifier","@methods"],[""," ) = "],["Identifier","@_"],["",";\n    "],["Conditional","if"],[""," ( "],["Operator","ref"],[""," "],["Identifier","$type_name"],[""," "],["Operator","eq"],[""," "],["String","'ARRAY'"],[""," && !"],["Identifier","@methods"],[""," ) {\n        "],["Identifier","@methods"],["","   = "],["Identifier","@$type_name"],["",";\n        "],["Identifier","$type_name"],[""," = "],["Operator","undef"],["",";\n    }\n    "],["Conditional","if"],[""," ( "],["Identifier","@methods"],[""," == "],["Number","1"],[""," && "],["Operator","ref"],[""," "],["Identifier","$methods["],["Number","0"],["Identifier","]"],[""," "],["Operator","eq"],[""," "],["String","'ARRAY'"],[""," ) {\n        "],["Identifier","@methods"],[""," = "],["Identifier","@{"],[""," "],["Identifier","$methods["],["Number","0"],["Identifier","]"],[""," "],["Identifier","}"],["",";\n    }\n\n    register_type_constraint(\n        create_duck_type_constraint(\n            "],["Identifier","$type_name"],["",",\n            \\"],["Identifier","@methods"],["",",\n        )\n    );\n}\n\n"],["Keyword","sub "],["Function","coerce "],["","{\n    "],["Statement","my"],[""," ( "],["Identifier","$type_name"],["",", "],["Identifier","@coercion_map"],[""," ) = "],["Identifier","@_"],["",";\n    _install_type_coercions( "],["Identifier","$type_name"],["",", \\"],["Identifier","@coercion_map"],[""," );\n}\n\n"],["Comment","# The trick of returning @_ lets us avoid having to specify a"],["","\n"],["Comment","# prototype. Perl will parse this:"],["","\n"],["Comment","#"],["","\n"],["Comment","# subtype 'Foo'"],["","\n"],["Comment","#     => as 'Str'"],["","\n"],["Comment","#     => where { ... }"],["","\n"],["Comment","#"],["","\n"],["Comment","# as this:"],["","\n"],["Comment","#"],["","\n"],["Comment","# subtype( 'Foo', as( 'Str', where { ... } ) );"],["","\n"],["Comment","#"],["","\n"],["Comment","# If as() returns all its extra arguments, this just works, and"],["","\n"],["Comment","# preserves backwards compatibility."],["","\n"],["Keyword","sub "],["Function","as "],["","{ { "],["String","as"],[""," => "],["Statement","shift"],[""," }, "],["Identifier","@_"],[""," }\n"],["Keyword","sub "],["Function","where "],["Type","(&)"],["","       { { "],["String","where"],["","       => "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," } }\n"],["Keyword","sub "],["Function","message "],["Type","(&)"],["","     { { "],["String","message"],["","     => "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," } }\n"],["Keyword","sub "],["Function","optimize_as "],["Type","(&)"],[""," { { "],["String","optimize_as"],[""," => "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," } }\n"],["Keyword","sub "],["Function","inline_as "],["Type","(&)"],["","   { { "],["String","inline_as"],["","   => "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," } }\n\n"],["Keyword","sub "],["Function","from    "],["","{"],["Identifier","@_"],["","}\n"],["Keyword","sub "],["Function","via "],["Type","(&)"],[""," { "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," }\n\n"],["Keyword","sub "],["Function","enum "],["","{\n    "],["Statement","my"],[""," ( "],["Identifier","$type_name"],["",", "],["Identifier","@values"],[""," ) = "],["Identifier","@_"],["",";\n\n    "],["Comment","# "],["Todo","NOTE:"],["","\n    "],["Comment","# if only an array-ref is passed then"],["","\n    "],["Comment","# you get an anon-enum"],["","\n    "],["Comment","# - SL"],["","\n    "],["Conditional","if"],[""," ( "],["Operator","ref"],[""," "],["Identifier","$type_name"],[""," "],["Operator","eq"],[""," "],["String","'ARRAY'"],[""," ) {\n        "],["Identifier","@values"],[""," == "],["Number","0"],["","\n            || __PACKAGE__->_throw_error("],["String","\"enum called with an array reference and additional arguments. Did you mean to parenthesize the enum call's parameters?\""],["",");\n\n        "],["Identifier","@values"],["","    = "],["Identifier","@$type_name"],["",";\n        "],["Identifier","$type_name"],[""," = "],["Operator","undef"],["",";\n    }\n    "],["Conditional","if"],[""," ( "],["Identifier","@values"],[""," == "],["Number","1"],[""," && "],["Operator","ref"],[""," "],["Identifier","$values["],["Number","0"],["Identifier","]"],[""," "],["Operator","eq"],[""," "],["String","'ARRAY'"],[""," ) {\n        "],["Identifier","@values"],[""," = "],["Identifier","@{"],[""," "],["Identifier","$values["],["Number","0"],["Identifier","]"],[""," "],["Identifier","}"],["",";\n    }\n\n    register_type_constraint(\n        create_enum_type_constraint(\n            "],["Identifier","$type_name"],["",",\n            \\"],["Identifier","@values"],["",",\n        )\n    );\n}\n\n"],["Keyword","sub "],["Function","union "],["","{\n  "],["Statement","my"],[""," ( "],["Identifier","$type_name"],["",", "],["Identifier","@constraints"],[""," ) = "],["Identifier","@_"],["",";\n  "],["Conditional","if"],[""," ( "],["Operator","ref"],[""," "],["Identifier","$type_name"],[""," "],["Operator","eq"],[""," "],["String","'ARRAY'"],[""," ) {\n    "],["Identifier","@constraints"],[""," == "],["Number","0"],["","\n      || __PACKAGE__->_throw_error("],["String","\"union called with an array reference and additional arguments.\""],["",");\n    "],["Identifier","@constraints"],[""," = "],["Identifier","@$type_name"],["",";\n    "],["Identifier","$type_name"],["","   = "],["Operator","undef"],["",";\n  }\n  "],["Conditional","if"],[""," ( "],["Identifier","@constraints"],[""," == "],["Number","1"],[""," && "],["Operator","ref"],[""," "],["Identifier","$constraints["],["Number","0"],["Identifier","]"],[""," "],["Operator","eq"],[""," "],["String","'ARRAY'"],[""," ) {\n    "],["Identifier","@constraints"],[""," = "],["Identifier","@{"],[""," "],["Identifier","$constraints["],["Number","0"],["Identifier","]"],[""," "],["Identifier","}"],["",";\n  }\n  "],["Conditional","if"],[""," ( "],["Operator","defined"],[""," "],["Identifier","$type_name"],[""," ) {\n    "],["Statement","return"],[""," register_type_constraint(\n      create_named_type_constraint_union( "],["Identifier","$type_name"],["",", "],["Identifier","@constraints"],[""," )\n    );\n  }\n  "],["Statement","return"],[""," create_type_constraint_union( "],["Identifier","@constraints"],[""," );\n}\n\n"],["Keyword","sub "],["Function","create_enum_type_constraint "],["","{\n    "],["Statement","my"],[""," ( "],["Identifier","$type_name"],["",", "],["Identifier","$values"],[""," ) = "],["Identifier","@_"],["",";\n\n    Moose::Meta::TypeConstraint::Enum->new(\n        "],["String","name"],[""," => "],["Identifier","$type_name"],[""," || "],["String","'__ANON__'"],["",",\n        "],["String","values"],[""," => "],["Identifier","$values"],["",",\n    );\n}\n\n"],["Keyword","sub "],["Function","create_duck_type_constraint "],["","{\n    "],["Statement","my"],[""," ( "],["Identifier","$type_name"],["",", "],["Identifier","$methods"],[""," ) = "],["Identifier","@_"],["",";\n\n    Moose::Meta::TypeConstraint::DuckType->new(\n        "],["String","name"],[""," => "],["Identifier","$type_name"],[""," || "],["String","'__ANON__'"],["",",\n        "],["String","methods"],[""," => "],["Identifier","$methods"],["",",\n    );\n}\n\n"],["Keyword","sub "],["Function","match_on_type "],["","{\n    "],["Statement","my"],[""," ("],["Identifier","$to_match"],["",", "],["Identifier","@cases"],["",") = "],["Identifier","@_"],["",";\n    "],["Statement","my"],[""," "],["Identifier","$default"],["",";\n    "],["Conditional","if"],[""," ("],["Identifier","@cases"],[""," % "],["Number","2"],[""," != "],["Number","0"],["",") {\n        "],["Identifier","$default"],[""," = "],["Statement","pop"],[""," "],["Identifier","@cases"],["",";\n        ("],["Operator","ref"],[""," "],["Identifier","$default"],[""," "],["Operator","eq"],[""," "],["String","'CODE'"],["",")\n            || __PACKAGE__->_throw_error("],["String","\"Default case must be a CODE ref, not "],["Identifier","$default"],["String","\""],["",");\n    }\n    "],["Repeat","while"],[""," ("],["Identifier","@cases"],["",") {\n        "],["Statement","my"],[""," ("],["Identifier","$type"],["",", "],["Identifier","$action"],["",") = "],["Statement","splice"],[""," "],["Identifier","@cases"],["",", "],["Number","0"],["",", "],["Number","2"],["",";\n\n        "],["Conditional","unless"],[""," (blessed "],["Identifier","$type"],[""," && "],["Identifier","$type"],["","->isa("],["String","'Moose::Meta::TypeConstraint'"],["",")) {\n            "],["Identifier","$type"],[""," = find_or_parse_type_constraint("],["Identifier","$type"],["",")\n                 || __PACKAGE__->_throw_error("],["String","\"Cannot find or parse the type '"],["Identifier","$type"],["String","'\""],["",")\n        }\n\n        ("],["Operator","ref"],[""," "],["Identifier","$action"],[""," "],["Operator","eq"],[""," "],["String","'CODE'"],["",")\n            || __PACKAGE__->_throw_error("],["String","\"Match action must be a CODE ref, not "],["Identifier","$action"],["String","\""],["",");\n\n        "],["Conditional","if"],[""," ("],["Identifier","$type"],["","->check("],["Identifier","$to_match"],["",")) {\n            "],["Statement","local"],[""," "],["Identifier","$_"],[""," = "],["Identifier","$to_match"],["",";\n            "],["Statement","return"],[""," "],["Identifier","$action"],["","->("],["Identifier","$to_match"],["",");\n        }\n    }\n    ("],["Operator","defined"],[""," "],["Identifier","$default"],["",")\n        || __PACKAGE__->_throw_error("],["String","\"No cases matched for "],["Identifier","$to_match"],["String","\""],["",");\n    {\n        "],["Statement","local"],[""," "],["Identifier","$_"],[""," = "],["Identifier","$to_match"],["",";\n        "],["Statement","return"],[""," "],["Identifier","$default"],["","->("],["Identifier","$to_match"],["",");\n    }\n}\n\n\n"],["Comment","## --------------------------------------------------------"],["","\n"],["Comment","## desugaring functions ..."],["","\n"],["Comment","## --------------------------------------------------------"],["","\n\n"],["Keyword","sub "],["Function","_create_type_constraint "],["Type","($$$;$$)"],[""," {\n    "],["Statement","my"],[""," "],["Identifier","$name"],["","      = "],["Statement","shift"],["",";\n    "],["Statement","my"],[""," "],["Identifier","$parent"],["","    = "],["Statement","shift"],["",";\n    "],["Statement","my"],[""," "],["Identifier","$check"],["","     = "],["Statement","shift"],["",";\n    "],["Statement","my"],[""," "],["Identifier","$message"],["","   = "],["Statement","shift"],["",";\n    "],["Statement","my"],[""," "],["Identifier","$optimized"],[""," = "],["Statement","shift"],["",";\n    "],["Statement","my"],[""," "],["Identifier","$inlined"],["","   = "],["Statement","shift"],["",";\n\n    "],["Statement","my"],[""," "],["Identifier","$pkg_defined_in"],[""," = "],["Statement","scalar"],["","( "],["Statement","caller"],["","("],["Number","1"],["",") );\n\n    "],["Conditional","if"],[""," ( "],["Operator","defined"],[""," "],["Identifier","$name"],[""," ) {\n        "],["Statement","my"],[""," "],["Identifier","$type"],[""," = "],["Identifier","$REGISTRY"],["","->get_type_constraint("],["Identifier","$name"],["",");\n\n        ( "],["Identifier","$type"],["","->_package_defined_in "],["Operator","eq"],[""," "],["Identifier","$pkg_defined_in"],[""," )\n            || _confess(\n                  "],["String","\"The type constraint '"],["Identifier","$name"],["String","' has already been created in \""],["","\n                . "],["Identifier","$type"],["","->_package_defined_in\n                . "],["String","\" and cannot be created again in \""],["","\n                . "],["Identifier","$pkg_defined_in"],[""," )\n            "],["Conditional","if"],[""," "],["Operator","defined"],[""," "],["Identifier","$type"],["",";\n\n        "],["Identifier","$name"],[""," =~ "],["Statement","/"],["String","^["],["Special","\\w"],["String",":"],["Special","\\."],["String","]"],["Special","+"],["String","$"],["Statement","/"],["","\n            "],["Operator","or"],[""," "],["Statement","die"],[""," "],["String","qq{"],["Identifier","$name"],["String"," contains invalid characters for a type name.}"],["","\n            . "],["String","qq{ Names can contain alphanumeric character, \":\", and \".\""],["Special","\\n"],["String","}"],["",";\n    }\n\n    "],["Statement","my"],[""," "],["Identifier","%opts"],[""," = (\n        "],["String","name"],["","               => "],["Identifier","$name"],["",",\n        "],["String","package_defined_in"],[""," => "],["Identifier","$pkg_defined_in"],["",",\n\n        ( "],["Identifier","$check"],["","     ? ( "],["String","constraint"],[""," => "],["Identifier","$check"],[""," )     : () ),\n        ( "],["Identifier","$message"],["","   ? ( "],["String","message"],["","    => "],["Identifier","$message"],[""," )   : () ),\n        ( "],["Identifier","$optimized"],[""," ? ( "],["String","optimized"],["","  => "],["Identifier","$optimized"],[""," ) : () ),\n        ( "],["Identifier","$inlined"],["","   ? ( "],["String","inlined"],["","    => "],["Identifier","$inlined"],[""," )   : () ),\n    );\n\n    "],["Statement","my"],[""," "],["Identifier","$constraint"],["",";\n    "],["Conditional","if"],[""," (\n        "],["Operator","defined"],[""," "],["Identifier","$parent"],["","\n        "],["Operator","and"],[""," "],["Identifier","$parent"],["","\n        = blessed "],["Identifier","$parent"],["","\n        ? "],["Identifier","$parent"],["","\n        : find_or_create_isa_type_constraint("],["Identifier","$parent"],["",")\n        ) {\n        "],["Identifier","$constraint"],[""," = "],["Identifier","$parent"],["","->create_child_type("],["Identifier","%opts"],["",");\n    }\n    "],["Conditional","else"],[""," {\n        "],["Identifier","$constraint"],[""," = Moose::Meta::TypeConstraint->new("],["Identifier","%opts"],["",");\n    }\n\n    "],["Identifier","$REGISTRY"],["","->add_type_constraint("],["Identifier","$constraint"],["",")\n        "],["Conditional","if"],[""," "],["Operator","defined"],[""," "],["Identifier","$name"],["",";\n\n    "],["Statement","return"],[""," "],["Identifier","$constraint"],["",";\n}\n\n"],["Keyword","sub "],["Function","_install_type_coercions "],["Type","($$)"],[""," {\n    "],["Statement","my"],[""," ( "],["Identifier","$type_name"],["",", "],["Identifier","$coercion_map"],[""," ) = "],["Identifier","@_"],["",";\n    "],["Statement","my"],[""," "],["Identifier","$type"],[""," = find_type_constraint("],["Identifier","$type_name"],["",");\n    ( "],["Operator","defined"],[""," "],["Identifier","$type"],[""," )\n        || __PACKAGE__->_throw_error(\n        "],["String","\"Cannot find type '"],["Identifier","$type_name"],["String","', perhaps you forgot to load it\""],["",");\n    "],["Conditional","if"],[""," ( "],["Identifier","$type"],["","->has_coercion ) {\n        "],["Identifier","$type"],["","->coercion->add_type_coercions("],["Identifier","@$coercion_map"],["",");\n    }\n    "],["Conditional","else"],[""," {\n        "],["Statement","my"],[""," "],["Identifier","$type_coercion"],[""," = Moose::Meta::TypeCoercion->new(\n            "],["String","type_coercion_map"],[""," => "],["Identifier","$coercion_map"],["",",\n            "],["String","type_constraint"],["","   => "],["Identifier","$type"],["","\n        );\n        "],["Identifier","$type"],["","->coercion("],["Identifier","$type_coercion"],["",");\n    }\n}\n\n"],["Comment","## --------------------------------------------------------"],["","\n"],["Comment","## type notation parsing ..."],["","\n"],["Comment","## --------------------------------------------------------"],["","\n\n{\n\n    "],["Comment","# All I have to say is mugwump++ cause I know"],["","\n    "],["Comment","# do not even have enough regexp-fu to be able"],["","\n    "],["Comment","# to have written this (I can only barely"],["","\n    "],["Comment","# understand it as it is)"],["","\n    "],["Comment","# - SL"],["","\n\n    "],["Statement","use re"],[""," "],["String","\"eval\""],["",";\n\n    "],["Statement","my"],[""," "],["Identifier","$valid_chars"],[""," = "],["String","qr{["],["Special","\\w"],["String",":"],["Special","\\."],["String","]}"],["",";\n    "],["Statement","my"],[""," "],["Identifier","$type_atom"],["","   = "],["String","qr{ "],["Special","(?"],["String",">"],["Identifier","$valid_chars"],["Special","+)"],["String"," }x"],["",";\n    "],["Statement","my"],[""," "],["Identifier","$ws"],["","          = "],["String","qr{ "],["Special","(?"],["String",">"],["Special","\\s*)"],["String"," }x"],["",";\n    "],["Statement","my"],[""," "],["Identifier","$op_union"],["","    = "],["String","qr{ "],["Identifier","$ws"],["String"," "],["Special","\\|"],["String"," "],["Identifier","$ws"],["String"," }x"],["",";\n\n    "],["Statement","my"],[""," ("],["Identifier","$type"],["",", "],["Identifier","$type_capture_parts"],["",", "],["Identifier","$type_with_parameter"],["",", "],["Identifier","$union"],["",", "],["Identifier","$any"],["",");\n    "],["Conditional","if"],[""," (Class::MOP::IS_RUNNING_ON_5_10) {\n        "],["Statement","my"],[""," "],["Identifier","$type_pattern"],["","\n            = "],["String","q{  (?&type_atom)  (?: \\[ (?&ws)  (?&any)  (?&ws) \\] )? }"],["",";\n        "],["Statement","my"],[""," "],["Identifier","$type_capture_parts_pattern"],["","\n            = "],["String","q{ ((?&type_atom)) (?: \\[ (?&ws) ((?&any)) (?&ws) \\] )? }"],["",";\n        "],["Statement","my"],[""," "],["Identifier","$type_with_parameter_pattern"],["","\n            = "],["String","q{  (?&type_atom)      \\[ (?&ws)  (?&any)  (?&ws) \\]    }"],["",";\n        "],["Statement","my"],[""," "],["Identifier","$union_pattern"],["","\n            = "],["String","q{ (?&type) (?> (?: (?&op_union) (?&type) )+ ) }"],["",";\n        "],["Statement","my"],[""," "],["Identifier","$any_pattern"],["","\n            = "],["String","q{ (?&type) | (?&union) }"],["",";\n\n        "],["Statement","my"],[""," "],["Identifier","$defines"],[""," = "],["String","qr{"],["Special","(?("],["String","DEFINE"],["Special",")"],["","\n"],["String","            "],["Special","(?"],["String","<valid_chars>         "],["Identifier","$valid_chars"],["Special",")"],["","\n"],["String","            "],["Special","(?"],["String","<type_atom>           "],["Identifier","$type_atom"],["Special",")"],["","\n"],["String","            "],["Special","(?"],["String","<ws>                  "],["Identifier","$ws"],["Special",")"],["","\n"],["String","            "],["Special","(?"],["String","<op_union>            "],["Identifier","$op_union"],["Special",")"],["","\n"],["String","            "],["Special","(?"],["String","<type>                "],["Identifier","$type_pattern"],["Special",")"],["","\n"],["String","            "],["Special","(?"],["String","<type_capture_parts>  "],["Identifier","$type_capture_parts_pattern"],["Special",")"],["","\n"],["String","            "],["Special","(?"],["String","<type_with_parameter> "],["Identifier","$type_with_parameter_pattern"],["Special",")"],["","\n"],["String","            "],["Special","(?"],["String","<union>               "],["Identifier","$union_pattern"],["Special",")"],["","\n"],["String","            "],["Special","(?"],["String","<any>                 "],["Identifier","$any_pattern"],["Special",")"],["","\n"],["String","        "],["Special",")"],["String","}x"],["",";\n\n        "],["Identifier","$type"],["","                = "],["String","qr{ "],["Identifier","$type_pattern"],["String","                "],["Identifier","$defines"],["String"," }x"],["",";\n        "],["Identifier","$type_capture_parts"],["","  = "],["String","qr{ "],["Identifier","$type_capture_parts_pattern"],["String","  "],["Identifier","$defines"],["String"," }x"],["",";\n        "],["Identifier","$type_with_parameter"],[""," = "],["String","qr{ "],["Identifier","$type_with_parameter_pattern"],["String"," "],["Identifier","$defines"],["String"," }x"],["",";\n        "],["Identifier","$union"],["","               = "],["String","qr{ "],["Identifier","$union_pattern"],["String","               "],["Identifier","$defines"],["String"," }x"],["",";\n        "],["Identifier","$any"],["","                 = "],["String","qr{ "],["Identifier","$any_pattern"],["String","                 "],["Identifier","$defines"],["String"," }x"],["",";\n    }\n    "],["Conditional","else"],[""," {\n        "],["Identifier","$type"],["","\n            = "],["String","qr{  "],["Identifier","$type_atom"],["String","  "],["Special","(?:"],["String"," "],["Special","\\["],["String"," "],["Identifier","$ws"],["String","  "],["Special","(??"],["String","{"],["Identifier","$any"],["String","}"],["Special",")"],["String","  "],["Identifier","$ws"],["String"," "],["Special","\\]"],["String"," "],["Special",")?"],["String"," }x"],["",";\n        "],["Identifier","$type_capture_parts"],["","\n            = "],["String","qr{ "],["Special","("],["Identifier","$type_atom"],["Special",")"],["String"," "],["Special","(?:"],["String"," "],["Special","\\["],["String"," "],["Identifier","$ws"],["String"," "],["Special","((??"],["String","{"],["Identifier","$any"],["String","}"],["Special","))"],["String"," "],["Identifier","$ws"],["String"," "],["Special","\\]"],["String"," "],["Special",")?"],["String"," }x"],["",";\n        "],["Identifier","$type_with_parameter"],["","\n            = "],["String","qr{  "],["Identifier","$type_atom"],["String","      "],["Special","\\["],["String"," "],["Identifier","$ws"],["String","  "],["Special","(??"],["String","{"],["Identifier","$any"],["String","}"],["Special",")"],["String","  "],["Identifier","$ws"],["String"," "],["Special","\\]"],["String","    }x"],["",";\n        "],["Identifier","$union"],["","\n            = "],["String","qr{ "],["Identifier","$type"],["String"," "],["Special","(?"],["String","> "],["Special","(?:"],["String"," "],["Identifier","$op_union"],["String"," "],["Identifier","$type"],["String"," "],["Special",")+"],["String"," "],["Special",")"],["String"," }x"],["",";\n        "],["Identifier","$any"],["","\n            = "],["String","qr{ "],["Identifier","$type"],["String"," | "],["Identifier","$union"],["String"," }x"],["",";\n    }\n\n\n    "],["Keyword","sub "],["Function","_parse_parameterized_type_constraint "],["","{\n        { "],["Statement","no warnings"],[""," "],["String","'void'"],["","; "],["Identifier","$any"],["","; }  "],["Comment","# force capture of interpolated lexical"],["","\n        "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," =~ "],["Statement","m{"],["String"," "],["Identifier","$type_capture_parts"],["String"," "],["Statement","}x"],["",";\n        "],["Statement","return"],[""," ( "],["Identifier","$1"],["",", "],["Identifier","$2"],[""," );\n    }\n\n    "],["Keyword","sub "],["Function","_detect_parameterized_type_constraint "],["","{\n        { "],["Statement","no warnings"],[""," "],["String","'void'"],["","; "],["Identifier","$any"],["","; }  "],["Comment","# force capture of interpolated lexical"],["","\n        "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," =~ "],["Statement","m{"],["String"," ^ "],["Identifier","$type_with_parameter"],["String"," $ "],["Statement","}x"],["",";\n    }\n\n    "],["Keyword","sub "],["Function","_parse_type_constraint_union "],["","{\n        { "],["Statement","no warnings"],[""," "],["String","'void'"],["","; "],["Identifier","$any"],["","; }  "],["Comment","# force capture of interpolated lexical"],["","\n        "],["Statement","my"],[""," "],["Identifier","$given"],[""," = "],["Statement","shift"],["",";\n        "],["Statement","my"],[""," "],["Identifier","@rv"],["",";\n        "],["Repeat","while"],[""," ( "],["Identifier","$given"],[""," =~ "],["Statement","m{"],["String"," "],["Special","\\G"],["String"," "],["Special","(?:"],["String"," "],["Identifier","$op_union"],["String"," "],["Special",")?"],["String"," "],["Special","("],["Identifier","$type"],["Special",")"],["String"," "],["Statement","}gcx"],[""," ) {\n            "],["Statement","push"],[""," "],["Identifier","@rv"],[""," => "],["Identifier","$1"],["",";\n        }\n        ( "],["Statement","pos"],["","("],["Identifier","$given"],["",") "],["Operator","eq"],[""," "],["Statement","length"],["","("],["Identifier","$given"],["",") )\n            || __PACKAGE__->_throw_error( "],["String","\"'"],["Identifier","$given"],["String","' didn't parse (parse-pos=\""],["","\n                . "],["Statement","pos"],["","("],["Identifier","$given"],["",")\n                . "],["String","\" and str-length=\""],["","\n                . "],["Statement","length"],["","("],["Identifier","$given"],["",")\n                . "],["String","\")\""],[""," );\n        "],["Identifier","@rv"],["",";\n    }\n\n    "],["Keyword","sub "],["Function","_detect_type_constraint_union "],["","{\n        { "],["Statement","no warnings"],[""," "],["String","'void'"],["","; "],["Identifier","$any"],["","; }  "],["Comment","# force capture of interpolated lexical"],["","\n        "],["Identifier","$_["],["Number","0"],["Identifier","]"],[""," =~ "],["Statement","m{"],["String","^ "],["Identifier","$type"],["String"," "],["Identifier","$op_union"],["String"," "],["Identifier","$type"],["String"," "],["Special","("],["String"," "],["Identifier","$op_union"],["String"," "],["Special",".*"],["String"," "],["Special",")?"],["String"," $"],["Statement","}x"],["",";\n    }\n}\n\n"],["Comment","## --------------------------------------------------------"],["","\n"],["Comment","# define some basic built-in types"],["","\n"],["Comment","## --------------------------------------------------------"],["","\n\n"],["Comment","# By making these classes immutable before creating all the types in"],["","\n"],["Comment","# Moose::Util::TypeConstraints::Builtin , we avoid repeatedly calling the slow"],["","\n"],["Comment","# MOP-based accessors."],["","\n"],["Identifier","$_"],["","->make_immutable(\n    "],["String","inline_constructor"],[""," => "],["Number","1"],["",",\n    "],["String","constructor_name"],["","   => "],["String","\"_new\""],["",",\n\n    "],["Comment","# these are Class::MOP accessors, so they need inlining"],["","\n    "],["String","inline_accessors"],[""," => "],["Number","1"],["","\n    ) "],["Repeat","for"],[""," "],["Statement","grep"],[""," "],["Statement","{"],[""," "],["Identifier","$_"],["","->is_mutable "],["Statement","}"],["","\n    "],["Statement","map"],[""," "],["Statement","{"],[""," Class::MOP::class_of("],["Identifier","$_"],["",") "],["Statement","}"],["","\n    "],["String","qw("],["","\n"],["String","    Moose::Meta::TypeConstraint"],["","\n"],["String","    Moose::Meta::TypeConstraint::Union"],["","\n"],["String","    Moose::Meta::TypeConstraint::Parameterized"],["","\n"],["String","    Moose::Meta::TypeConstraint::Parameterizable"],["","\n"],["String","    Moose::Meta::TypeConstraint::Class"],["","\n"],["String","    Moose::Meta::TypeConstraint::Role"],["","\n"],["String","    Moose::Meta::TypeConstraint::Enum"],["","\n"],["String","    Moose::Meta::TypeConstraint::DuckType"],["","\n"],["String","    Moose::Meta::TypeConstraint::Registry"],["","\n"],["String",")"],["",";\n\n"],["Statement","require"],[""," Moose::Util::TypeConstraints::Builtins;\nMoose::Util::TypeConstraints::Builtins::define_builtins("],["Identifier","$REGISTRY"],["",");\n\n"],["Statement","my"],[""," "],["Identifier","@PARAMETERIZABLE_TYPES"],["","\n    = "],["Statement","map"],[""," "],["Statement","{"],[""," "],["Identifier","$REGISTRY"],["","->get_type_constraint("],["Identifier","$_"],["",") "],["Statement","}"],[""," "],["String","qw[ScalarRef ArrayRef HashRef Maybe]"],["",";\n\n"],["Keyword","sub "],["Function","get_all_parameterizable_types "],["","{"],["Identifier","@PARAMETERIZABLE_TYPES"],["","}\n\n"],["Keyword","sub "],["Function","add_parameterizable_type "],["","{\n    "],["Statement","my"],[""," "],["Identifier","$type"],[""," = "],["Statement","shift"],["",";\n    ( blessed "],["Identifier","$type"],["","\n            && "],["Identifier","$type"],["","->isa("],["String","'Moose::Meta::TypeConstraint::Parameterizable'"],["",") )\n        || __PACKAGE__->_throw_error(\n        "],["String","\"Type must be a Moose::Meta::TypeConstraint::Parameterizable not "],["Identifier","$type"],["String","\""],["","\n        );\n    "],["Statement","push"],[""," "],["Identifier","@PARAMETERIZABLE_TYPES"],[""," => "],["Identifier","$type"],["",";\n}\n\n"],["Comment","## --------------------------------------------------------"],["","\n"],["Comment","# end of built-in types ..."],["","\n"],["Comment","## --------------------------------------------------------"],["","\n\n{\n    "],["Statement","my"],[""," "],["Identifier","@BUILTINS"],[""," = list_all_type_constraints();\n    "],["Keyword","sub "],["Function","list_all_builtin_type_constraints "],["","{"],["Identifier","@BUILTINS"],["","}\n}\n\n"],["Keyword","sub "],["Function","_throw_error "],["","{\n    "],["Statement","shift"],["",";\n    "],["Statement","require"],[""," Moose;\n    "],["Statement","unshift"],[""," "],["Identifier","@_"],["",", "],["String","'Moose'"],["",";\n    "],["Statement","goto"],[""," "],["Identifier","&"],["Type","Moose::"],["Identifier","throw_error"],["",";\n}\n\n"],["Number","1"],["",";\n\n"],["Comment","# ABSTRACT: Type constraint system for Moose"],["","\n\n"],["Comment","__END__"],["","\n\n"],["Statement","=pod"],["","\n\n"],["Statement","=head1"],[""," "],["String","NAME"],["","\n\nMoose::Util::TypeConstraints - Type constraint system for Moose\n\n"],["Statement","=head1"],[""," "],["String","VERSION"],["","\n\nversion 2.1005\n\n"],["Statement","=head1"],[""," "],["String","SYNOPSIS"],["","\n\n"],["PreProc","  use Moose::Util::TypeConstraints;"],["","\n\n"],["PreProc","  subtype 'Natural',"],["","\n"],["PreProc","      as 'Int',"],["","\n"],["PreProc","      where { $_ > 0 };"],["","\n\n"],["PreProc","  subtype 'NaturalLessThanTen',"],["","\n"],["PreProc","      as 'Natural',"],["","\n"],["PreProc","      where { $_ < 10 },"],["","\n"],["PreProc","      message { \"This number ($_) is not less than ten!\" };"],["","\n\n"],["PreProc","  coerce 'Num',"],["","\n"],["PreProc","      from 'Str',"],["","\n"],["PreProc","      via { 0+$_ };"],["","\n\n"],["PreProc","  class_type 'DateTimeClass', { class => 'DateTime' };"],["","\n\n"],["PreProc","  role_type 'Barks', { role => 'Some::Library::Role::Barks' };"],["","\n\n"],["PreProc","  enum 'RGBColors', [qw(red green blue)];"],["","\n\n"],["PreProc","  union 'StringOrArray', [qw( String Array )];"],["","\n\n"],["PreProc","  no Moose::Util::TypeConstraints;"],["","\n\n"],["Statement","=head1"],[""," "],["String","DESCRIPTION"],["","\n\nThis module provides Moose with the ability to create custom type\nconstraints to be used in attribute definition.\n\n"],["Statement","=head2"],[""," "],["String","Important Caveat"],["","\n\nThis is "],["Identifier","B<NOT>"],[""," a type system for Perl 5. These are type constraints,\nand they are not used by Moose unless you tell it to. No type\ninference is performed, expressions are not typed, etc. etc. etc.\n\nA type constraint is at heart a small \"check if a value is valid\"\nfunction. A constraint can be associated with an attribute. This\nsimplifies parameter validation, and makes your code clearer to read,\nbecause you can refer to constraints by name.\n\n"],["Statement","=head2"],[""," "],["String","Slightly Less Important Caveat"],["","\n\nIt is "],["Identifier","B<always>"],[""," a good idea to quote your type names.\n\nThis prevents Perl from trying to execute the call as an indirect\nobject call. This can be an issue when you have a subtype with the\nsame name as a valid class.\n\nFor instance:\n\n"],["PreProc","  subtype DateTime => as Object => where { $_->isa('DateTime') };"],["","\n\nwill "],["Identifier","I<just work>"],["",", while this:\n\n"],["PreProc","  use DateTime;"],["","\n"],["PreProc","  subtype DateTime => as Object => where { $_->isa('DateTime') };"],["","\n\nwill fail silently and cause many headaches. The simple way to solve\nthis, as well as future proof your subtypes from classes which have\nyet to have been created, is to quote the type name:\n\n"],["PreProc","  use DateTime;"],["","\n"],["PreProc","  subtype 'DateTime', as 'Object', where { $_->isa('DateTime') };"],["","\n\n"],["Statement","=head2"],[""," "],["String","Default Type Constraints"],["","\n\nThis module also provides a simple hierarchy for Perl 5 types, here is\nthat hierarchy represented visually.\n\n"],["PreProc","  Any"],["","\n"],["PreProc","      Item"],["","\n"],["PreProc","          Bool"],["","\n"],["PreProc","          Maybe[`a]"],["","\n"],["PreProc","          Undef"],["","\n"],["PreProc","          Defined"],["","\n"],["PreProc","              Value"],["","\n"],["PreProc","                  Str"],["","\n"],["PreProc","                      Num"],["","\n"],["PreProc","                          Int"],["","\n"],["PreProc","                      ClassName"],["","\n"],["PreProc","                      RoleName"],["","\n"],["PreProc","              Ref"],["","\n"],["PreProc","                  ScalarRef[`a]"],["","\n"],["PreProc","                  ArrayRef[`a]"],["","\n"],["PreProc","                  HashRef[`a]"],["","\n"],["PreProc","                  CodeRef"],["","\n"],["PreProc","                  RegexpRef"],["","\n"],["PreProc","                  GlobRef"],["","\n"],["PreProc","                  FileHandle"],["","\n"],["PreProc","                  Object"],["","\n\n"],["Identifier","B<NOTE:>"],[""," Any type followed by a type parameter "],["Identifier","C<[`a]>"],[""," can be\nparameterized, this means you can say:\n\n"],["PreProc","  ArrayRef[Int]    # an array of integers"],["","\n"],["PreProc","  HashRef[CodeRef] # a hash of str to CODE ref mappings"],["","\n"],["PreProc","  ScalarRef[Int]   # a reference to an integer"],["","\n"],["PreProc","  Maybe[Str]       # value may be a string, may be undefined"],["","\n\nIf Moose finds a name in brackets that it does not recognize as an\nexisting type, it assumes that this is a class name, for example\n"],["Identifier","C<ArrayRef[DateTime]>"],["",".\n\n"],["Identifier","B<NOTE:>"],[""," Unless you parameterize a type, then it is invalid to include\nthe square brackets. I.e. "],["Identifier","C<ArrayRef[]>"],[""," will be treated as a new type\nname, "],["Identifier","I<not>"],[""," as a parameterization of "],["Identifier","C<ArrayRef>"],["",".\n\n"],["Identifier","B<NOTE:>"],[""," The "],["Identifier","C<Undef>"],[""," type constraint for the most part works\ncorrectly now, but edge cases may still exist, please use it\nsparingly.\n\n"],["Identifier","B<NOTE:>"],[""," The "],["Identifier","C<ClassName>"],[""," type constraint does a complex package\nexistence check. This means that your class "],["Identifier","B<must>"],[""," be loaded for this\ntype constraint to pass.\n\n"],["Identifier","B<NOTE:>"],[""," The "],["Identifier","C<RoleName>"],[""," constraint checks a string is a "],["Identifier","I<package"],["","\n"],["Identifier","name>"],[""," which is a role, like "],["Identifier","C<'MyApp::Role::Comparable'>"],["",".\n\n"],["Statement","=head2"],[""," "],["String","Type Constraint Naming"],["","\n\nType name declared via this module can only contain alphanumeric\ncharacters, colons (:), and periods (.).\n\nSince the types created by this module are global, it is suggested\nthat you namespace your types just as you would namespace your\nmodules. So instead of creating a "],["Identifier","I<Color>"],[""," type for your\n"],["Identifier","B<My::Graphics>"],[""," module, you would call the type\n"],["Identifier","I<My::Graphics::Types::Color>"],[""," instead.\n\n"],["Statement","=head2"],[""," "],["String","Use with Other Constraint Modules"],["","\n\nThis module can play nicely with other constraint modules with some\nslight tweaking. The "],["Identifier","C<where>"],[""," clause in types is expected to be a\n"],["Identifier","C<CODE>"],[""," reference which checks its first argument and returns a\nboolean. Since most constraint modules work in a similar way, it\nshould be simple to adapt them to work with Moose.\n\nFor instance, this is how you could use it with\n"],["Identifier","L<Declare::Constraints::Simple>"],[""," to declare a completely new type.\n\n"],["PreProc","  type 'HashOfArrayOfObjects',"],["","\n"],["PreProc","      where {"],["","\n"],["PreProc","          IsHashRef("],["","\n"],["PreProc","              -keys   => HasLength,"],["","\n"],["PreProc","              -values => IsArrayRef(IsObject)"],["","\n"],["PreProc","          )->(@_);"],["","\n"],["PreProc","      };"],["","\n\nFor more examples see the "],["Identifier","F<t/examples/example_w_DCS.t>"],[""," test\nfile.\n\nHere is an example of using "],["Identifier","L<Test::Deep>"],[""," and its non-test\nrelated "],["Identifier","C<eq_deeply>"],[""," function.\n\n"],["PreProc","  type 'ArrayOfHashOfBarsAndRandomNumbers',"],["","\n"],["PreProc","      where {"],["","\n"],["PreProc","          eq_deeply($_,"],["","\n"],["PreProc","              array_each(subhashof({"],["","\n"],["PreProc","                  bar           => isa('Bar'),"],["","\n"],["PreProc","                  random_number => ignore()"],["","\n"],["PreProc","              })))"],["","\n"],["PreProc","        };"],["","\n\nFor a complete example see the\n"],["Identifier","F<t/examples/example_w_TestDeep.t>"],[""," test file.\n\n"],["Statement","=head2"],[""," "],["String","Error messages"],["","\n\nType constraints can also specify custom error messages, for when they fail to\nvalidate. This is provided as just another coderef, which receives the invalid\nvalue in "],["Identifier","C<$_>"],["",", as in:\n\n"],["PreProc","  subtype 'PositiveInt',"],["","\n"],["PreProc","       as 'Int',"],["","\n"],["PreProc","       where { $_ > 0 },"],["","\n"],["PreProc","       message { \"$_ is not a positive integer!\" };"],["","\n\nIf no message is specified, a default message will be used, which indicates\nwhich type constraint was being used and what value failed. If\n"],["Identifier","L<Devel::PartialDump>"],[""," (version 0.14 or higher) is installed, it will be used to\ndisplay the invalid value, otherwise it will just be printed as is.\n\n"],["Statement","=head1"],[""," "],["String","FUNCTIONS"],["","\n\n"],["Statement","=head2"],[""," "],["String","Type Constraint Constructors"],["","\n\nThe following functions are used to create type constraints.  They\nwill also register the type constraints your create in a global\nregistry that is used to look types up by name.\n\nSee the "],["Identifier","L</SYNOPSIS>"],[""," for an example of how to use these.\n\n"],["Statement","=over"],[""," "],["Number","4"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<< subtype 'Name', as 'Parent', where { } ... >>"],["","\n\nThis creates a named subtype.\n\nIf you provide a parent that Moose does not recognize, it will\nautomatically create a new class type constraint for this name.\n\nWhen creating a named type, the "],["Identifier","C<subtype>"],[""," function should either be\ncalled with the sugar helpers ("],["Identifier","C<where>"],["",", "],["Identifier","C<message>"],["",", etc), or with a\nname and a hashref of parameters:\n\n"],["PreProc"," subtype( 'Foo', { where => ..., message => ... } );"],["","\n\nThe valid hashref keys are "],["Identifier","C<as>"],[""," (the parent), "],["Identifier","C<where>"],["",", "],["Identifier","C<message>"],["",",\nand "],["Identifier","C<optimize_as>"],["",".\n\n"],["Statement","=item"],[""," "],["Identifier","B<< subtype as 'Parent', where { } ... >>"],["","\n\nThis creates an unnamed subtype and will return the type\nconstraint meta-object, which will be an instance of\n"],["Identifier","L<Moose::Meta::TypeConstraint>"],["",".\n\nWhen creating an anonymous type, the "],["Identifier","C<subtype>"],[""," function should either\nbe called with the sugar helpers ("],["Identifier","C<where>"],["",", "],["Identifier","C<message>"],["",", etc), or with\njust a hashref of parameters:\n\n"],["PreProc"," subtype( { where => ..., message => ... } );"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<class_type ($class, ?$options)>"],["","\n\nCreates a new subtype of "],["Identifier","C<Object>"],[""," with the name "],["Identifier","C<$class>"],[""," and the\nmetaclass "],["Identifier","L<Moose::Meta::TypeConstraint::Class>"],["",".\n\n"],["PreProc","  # Create a type called 'Box' which tests for objects which ->isa('Box')"],["","\n"],["PreProc","  class_type 'Box';"],["","\n\nBy default, the name of the type and the name of the class are the same, but\nyou can specify both separately.\n\n"],["PreProc","  # Create a type called 'Box' which tests for objects which ->isa('ObjectLibrary::Box');"],["","\n"],["PreProc","  class_type 'Box', { class => 'ObjectLibrary::Box' };"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<role_type ($role, ?$options)>"],["","\n\nCreates a "],["Identifier","C<Role>"],[""," type constraint with the name "],["Identifier","C<$role>"],[""," and the\nmetaclass "],["Identifier","L<Moose::Meta::TypeConstraint::Role>"],["",".\n\n"],["PreProc","  # Create a type called 'Walks' which tests for objects which ->does('Walks')"],["","\n"],["PreProc","  role_type 'Walks';"],["","\n\nBy default, the name of the type and the name of the role are the same, but\nyou can specify both separately.\n\n"],["PreProc","  # Create a type called 'Walks' which tests for objects which ->does('MooseX::Role::Walks');"],["","\n"],["PreProc","  role_type 'Walks', { role => 'MooseX::Role::Walks' };"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<maybe_type ($type)>"],["","\n\nCreates a type constraint for either "],["Identifier","C<undef>"],[""," or something of the\ngiven type.\n\n"],["Statement","=item"],[""," "],["Identifier","B<duck_type ($name, \\@methods)>"],["","\n\nThis will create a subtype of Object and test to make sure the value\n"],["Identifier","C<can()>"],[""," do the methods in "],["Identifier","C<\\@methods>"],["",".\n\nThis is intended as an easy way to accept non-Moose objects that\nprovide a certain interface. If you're using Moose classes, we\nrecommend that you use a "],["Identifier","C<requires>"],["","-only Role instead.\n\n"],["Statement","=item"],[""," "],["Identifier","B<duck_type (\\@methods)>"],["","\n\nIf passed an ARRAY reference as the only parameter instead of the\n"],["Identifier","C<$name>"],["",", "],["Identifier","C<\\@methods>"],[""," pair, this will create an unnamed duck type.\nThis can be used in an attribute definition like so:\n\n"],["PreProc","  has 'cache' => ("],["","\n"],["PreProc","      is  => 'ro',"],["","\n"],["PreProc","      isa => duck_type( [qw( get_set )] ),"],["","\n"],["PreProc","  );"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<enum ($name, \\@values)>"],["","\n\nThis will create a basic subtype for a given set of strings.\nThe resulting constraint will be a subtype of "],["Identifier","C<Str>"],[""," and\nwill match any of the items in "],["Identifier","C<\\@values>"],["",". It is case sensitive.\nSee the "],["Identifier","L</SYNOPSIS>"],[""," for a simple example.\n\n"],["Identifier","B<NOTE:>"],[""," This is not a true proper enum type, it is simply\na convenient constraint builder.\n\n"],["Statement","=item"],[""," "],["Identifier","B<enum (\\@values)>"],["","\n\nIf passed an ARRAY reference as the only parameter instead of the\n"],["Identifier","C<$name>"],["",", "],["Identifier","C<\\@values>"],[""," pair, this will create an unnamed enum. This\ncan then be used in an attribute definition like so:\n\n"],["PreProc","  has 'sort_order' => ("],["","\n"],["PreProc","      is  => 'ro',"],["","\n"],["PreProc","      isa => enum([qw[ ascending descending ]]),"],["","\n"],["PreProc","  );"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<union ($name, \\@constraints)>"],["","\n\nThis will create a basic subtype where any of the provided constraints\nmay match in order to satisfy this constraint.\n\n"],["Statement","=item"],[""," "],["Identifier","B<union (\\@constraints)>"],["","\n\nIf passed an ARRAY reference as the only parameter instead of the\n"],["Identifier","C<$name>"],["",", "],["Identifier","C<\\@constraints>"],[""," pair, this will create an unnamed union.\nThis can then be used in an attribute definition like so:\n\n"],["PreProc","  has 'items' => ("],["","\n"],["PreProc","      is => 'ro',"],["","\n"],["PreProc","      isa => union([qw[ Str ArrayRef ]]),"],["","\n"],["PreProc","  );"],["","\n\nThis is similar to the existing string union:\n\n"],["PreProc","  isa => 'Str|ArrayRef'"],["","\n\nexcept that it supports anonymous elements as child constraints:\n\n"],["PreProc","  has 'color' => ("],["","\n"],["PreProc","    isa => 'ro',"],["","\n"],["PreProc","    isa => union([ 'Int',  enum([qw[ red green blue ]]) ]),"],["","\n"],["PreProc","  );"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<as 'Parent'>"],["","\n\nThis is just sugar for the type constraint construction syntax.\n\nIt takes a single argument, which is the name of a parent type.\n\n"],["Statement","=item"],[""," "],["Identifier","B<where { ... }>"],["","\n\nThis is just sugar for the type constraint construction syntax.\n\nIt takes a subroutine reference as an argument. When the type\nconstraint is tested, the reference is run with the value to be tested\nin "],["Identifier","C<$_>"],["",". This reference should return true or false to indicate\nwhether or not the constraint check passed.\n\n"],["Statement","=item"],[""," "],["Identifier","B<message { ... }>"],["","\n\nThis is just sugar for the type constraint construction syntax.\n\nIt takes a subroutine reference as an argument. When the type\nconstraint fails, then the code block is run with the value provided\nin "],["Identifier","C<$_>"],["",". This reference should return a string, which will be used in\nthe text of the exception thrown.\n\n"],["Statement","=item"],[""," "],["Identifier","B<inline_as { ... }>"],["","\n\nThis can be used to define a \"hand optimized\" inlinable version of your type\nconstraint.\n\nYou provide a subroutine which will be called "],["Identifier","I<as a method>"],[""," on a\n"],["Identifier","L<Moose::Meta::TypeConstraint>"],[""," object. It will receive a single parameter, the\nname of the variable to check, typically something like "],["Identifier","C<\"$_\">"],[""," or "],["Identifier","C<\"$_[0]\">"],["",".\n\nThe subroutine should return a code string suitable for inlining. You can\nassume that the check will be wrapped in parentheses when it is inlined.\n\nThe inlined code should include any checks that your type's parent types\ndo. If your parent type constraint defines its own inlining, you can simply use\nthat to avoid repeating code. For example, here is the inlining code for the\n"],["Identifier","C<Value>"],[""," type, which is a subtype of "],["Identifier","C<Defined>"],["",":\n\n"],["PreProc","    sub {"],["","\n"],["PreProc","        $_[0]->parent()->_inline_check($_[1])"],["","\n"],["PreProc","        . ' && !ref(' . $_[1] . ')'"],["","\n"],["PreProc","    }"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<optimize_as { ... }>"],["","\n\n"],["Identifier","B<This feature is deprecated, use C<inline_as> instead.>"],["","\n\nThis can be used to define a \"hand optimized\" version of your\ntype constraint which can be used to avoid traversing a subtype\nconstraint hierarchy.\n\n"],["Identifier","B<NOTE:>"],[""," You should only use this if you know what you are doing.\nAll the built in types use this, so your subtypes (assuming they\nare shallow) will not likely need to use this.\n\n"],["Statement","=item"],[""," "],["Identifier","B<< type 'Name', where { } ... >>"],["","\n\nThis creates a base type, which has no parent.\n\nThe "],["Identifier","C<type>"],[""," function should either be called with the sugar helpers\n("],["Identifier","C<where>"],["",", "],["Identifier","C<message>"],["",", etc), or with a name and a hashref of\nparameters:\n\n"],["PreProc","  type( 'Foo', { where => ..., message => ... } );"],["","\n\nThe valid hashref keys are "],["Identifier","C<where>"],["",", "],["Identifier","C<message>"],["",", and "],["Identifier","C<inlined_as>"],["",".\n\n"],["Statement","=back"],["","\n\n"],["Statement","=head2"],[""," "],["String","Type Constraint Utilities"],["","\n\n"],["Statement","=over"],[""," "],["Number","4"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<< match_on_type $value => ( $type => \\&action, ... ?\\&default ) >>"],["","\n\nThis is a utility function for doing simple type based dispatching similar to\nmatch/case in OCaml and case/of in Haskell. It is not as featureful as those\nlanguages, nor does not it support any kind of automatic destructuring\nbind. Here is a simple Perl pretty printer dispatching over the core Moose\ntypes.\n\n"],["PreProc","  sub ppprint {"],["","\n"],["PreProc","      my $x = shift;"],["","\n"],["PreProc","      match_on_type $x => ("],["","\n"],["PreProc","          HashRef => sub {"],["","\n"],["PreProc","              my $hash = shift;"],["","\n"],["PreProc","              '{ '"],["","\n"],["PreProc","                  . ("],["","\n"],["PreProc","                  join \", \" => map { $_ . ' => ' . ppprint( $hash->{$_} ) }"],["","\n"],["PreProc","                      sort keys %$hash"],["","\n"],["PreProc","                  ) . ' }';"],["","\n"],["PreProc","          },"],["","\n"],["PreProc","          ArrayRef => sub {"],["","\n"],["PreProc","              my $array = shift;"],["","\n"],["PreProc","              '[ ' . ( join \", \" => map { ppprint($_) } @$array ) . ' ]';"],["","\n"],["PreProc","          },"],["","\n"],["PreProc","          CodeRef   => sub {'sub { ... }'},"],["","\n"],["PreProc","          RegexpRef => sub { 'qr/' . $_ . '/' },"],["","\n"],["PreProc","          GlobRef   => sub { '*' . B::svref_2object($_)->NAME },"],["","\n"],["PreProc","          Object    => sub { $_->can('to_string') ? $_->to_string : $_ },"],["","\n"],["PreProc","          ScalarRef => sub { '\\\\' . ppprint( ${$_} ) },"],["","\n"],["PreProc","          Num       => sub {$_},"],["","\n"],["PreProc","          Str       => sub { '\"' . $_ . '\"' },"],["","\n"],["PreProc","          Undef     => sub {'undef'},"],["","\n"],["PreProc","          => sub { die \"I don't know what $_ is\" }"],["","\n"],["PreProc","      );"],["","\n"],["PreProc","  }"],["","\n\nOr a simple JSON serializer:\n\n"],["PreProc","  sub to_json {"],["","\n"],["PreProc","      my $x = shift;"],["","\n"],["PreProc","      match_on_type $x => ("],["","\n"],["PreProc","          HashRef => sub {"],["","\n"],["PreProc","              my $hash = shift;"],["","\n"],["PreProc","              '{ '"],["","\n"],["PreProc","                  . ("],["","\n"],["PreProc","                  join \", \" =>"],["","\n"],["PreProc","                      map { '\"' . $_ . '\" : ' . to_json( $hash->{$_} ) }"],["","\n"],["PreProc","                      sort keys %$hash"],["","\n"],["PreProc","                  ) . ' }';"],["","\n"],["PreProc","          },"],["","\n"],["PreProc","          ArrayRef => sub {"],["","\n"],["PreProc","              my $array = shift;"],["","\n"],["PreProc","              '[ ' . ( join \", \" => map { to_json($_) } @$array ) . ' ]';"],["","\n"],["PreProc","          },"],["","\n"],["PreProc","          Num   => sub {$_},"],["","\n"],["PreProc","          Str   => sub { '\"' . $_ . '\"' },"],["","\n"],["PreProc","          Undef => sub {'null'},"],["","\n"],["PreProc","          => sub { die \"$_ is not acceptable json type\" }"],["","\n"],["PreProc","      );"],["","\n"],["PreProc","  }"],["","\n\nThe matcher is done by mapping a "],["Identifier","C<$type>"],[""," to an "],["Identifier","C<\\&action>"],["",". The "],["Identifier","C<$type>"],[""," can\nbe either a string type or a "],["Identifier","L<Moose::Meta::TypeConstraint>"],[""," object, and\n"],["Identifier","C<\\&action>"],[""," is a subroutine reference. This function will dispatch on the\nfirst match for "],["Identifier","C<$value>"],["",". It is possible to have a catch-all by providing an\nadditional subroutine reference as the final argument to "],["Identifier","C<match_on_type>"],["",".\n\n"],["Statement","=back"],["","\n\n"],["Statement","=head2"],[""," "],["String","Type Coercion Constructors"],["","\n\nYou can define coercions for type constraints, which allow you to\nautomatically transform values to something valid for the type\nconstraint. If you ask your accessor to coerce, then Moose will run\nthe type-coercion code first, followed by the type constraint\ncheck. This feature should be used carefully as it is very powerful\nand could easily take off a limb if you are not careful.\n\nSee the "],["Identifier","L</SYNOPSIS>"],[""," for an example of how to use these.\n\n"],["Statement","=over"],[""," "],["Number","4"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<< coerce 'Name', from 'OtherName', via { ... }  >>"],["","\n\nThis defines a coercion from one type to another. The "],["Identifier","C<Name>"],[""," argument\nis the type you are coercing "],["Identifier","I<to>"],["",".\n\nTo define multiple coercions, supply more sets of from/via pairs:\n\n"],["PreProc","  coerce 'Name',"],["","\n"],["PreProc","    from 'OtherName', via { ... },"],["","\n"],["PreProc","    from 'ThirdName', via { ... };"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<from 'OtherName'>"],["","\n\nThis is just sugar for the type coercion construction syntax.\n\nIt takes a single type name (or type object), which is the type being\ncoerced "],["Identifier","I<from>"],["",".\n\n"],["Statement","=item"],[""," "],["Identifier","B<via { ... }>"],["","\n\nThis is just sugar for the type coercion construction syntax.\n\nIt takes a subroutine reference. This reference will be called with\nthe value to be coerced in "],["Identifier","C<$_>"],["",". It is expected to return a new value\nof the proper type for the coercion.\n\n"],["Statement","=back"],["","\n\n"],["Statement","=head2"],[""," "],["String","Creating and Finding Type Constraints"],["","\n\nThese are additional functions for creating and finding type\nconstraints. Most of these functions are not available for\nimporting. The ones that are importable as specified.\n\n"],["Statement","=over"],[""," "],["Number","4"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<find_type_constraint($type_name)>"],["","\n\nThis function can be used to locate the "],["Identifier","L<Moose::Meta::TypeConstraint>"],["","\nobject for a named type.\n\nThis function is importable.\n\n"],["Statement","=item"],[""," "],["Identifier","B<register_type_constraint($type_object)>"],["","\n\nThis function will register a "],["Identifier","L<Moose::Meta::TypeConstraint>"],[""," with the\nglobal type registry.\n\nThis function is importable.\n\n"],["Statement","=item"],[""," "],["Identifier","B<normalize_type_constraint_name($type_constraint_name)>"],["","\n\nThis method takes a type constraint name and returns the normalized\nform. This removes any whitespace in the string.\n\n"],["Statement","=item"],[""," "],["Identifier","B<create_type_constraint_union($pipe_separated_types | @type_constraint_names)>"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<create_named_type_constraint_union($name, $pipe_separated_types | @type_constraint_names)>"],["","\n\nThis can take a union type specification like "],["Identifier","C<'Int|ArrayRef[Int]'>"],["",",\nor a list of names. It returns a new\n"],["Identifier","L<Moose::Meta::TypeConstraint::Union>"],[""," object.\n\n"],["Statement","=item"],[""," "],["Identifier","B<create_parameterized_type_constraint($type_name)>"],["","\n\nGiven a "],["Identifier","C<$type_name>"],[""," in the form of "],["Identifier","C<'BaseType[ContainerType]'>"],["",",\nthis will create a new "],["Identifier","L<Moose::Meta::TypeConstraint::Parameterized>"],["","\nobject. The "],["Identifier","C<BaseType>"],[""," must exist already exist as a parameterizable\ntype.\n\n"],["Statement","=item"],[""," "],["Identifier","B<create_class_type_constraint($class, $options)>"],["","\n\nGiven a class name this function will create a new\n"],["Identifier","L<Moose::Meta::TypeConstraint::Class>"],[""," object for that class name.\n\nThe "],["Identifier","C<$options>"],[""," is a hash reference that will be passed to the\n"],["Identifier","L<Moose::Meta::TypeConstraint::Class>"],[""," constructor (as a hash).\n\n"],["Statement","=item"],[""," "],["Identifier","B<create_role_type_constraint($role, $options)>"],["","\n\nGiven a role name this function will create a new\n"],["Identifier","L<Moose::Meta::TypeConstraint::Role>"],[""," object for that role name.\n\nThe "],["Identifier","C<$options>"],[""," is a hash reference that will be passed to the\n"],["Identifier","L<Moose::Meta::TypeConstraint::Role>"],[""," constructor (as a hash).\n\n"],["Statement","=item"],[""," "],["Identifier","B<create_enum_type_constraint($name, $values)>"],["","\n\nGiven a enum name this function will create a new\n"],["Identifier","L<Moose::Meta::TypeConstraint::Enum>"],[""," object for that enum name.\n\n"],["Statement","=item"],[""," "],["Identifier","B<create_duck_type_constraint($name, $methods)>"],["","\n\nGiven a duck type name this function will create a new\n"],["Identifier","L<Moose::Meta::TypeConstraint::DuckType>"],[""," object for that enum name.\n\n"],["Statement","=item"],[""," "],["Identifier","B<find_or_parse_type_constraint($type_name)>"],["","\n\nGiven a type name, this first attempts to find a matching constraint\nin the global registry.\n\nIf the type name is a union or parameterized type, it will create a\nnew object of the appropriate, but if given a \"regular\" type that does\nnot yet exist, it simply returns false.\n\nWhen given a union or parameterized type, the member or base type must\nalready exist.\n\nIf it creates a new union or parameterized type, it will add it to the\nglobal registry.\n\n"],["Statement","=item"],[""," "],["Identifier","B<find_or_create_isa_type_constraint($type_name)>"],["","\n\n"],["Statement","=item"],[""," "],["Identifier","B<find_or_create_does_type_constraint($type_name)>"],["","\n\nThese functions will first call "],["Identifier","C<find_or_parse_type_constraint>"],["",". If\nthat function does not return a type, a new type object will\nbe created.\n\nThe "],["Identifier","C<isa>"],[""," variant will use "],["Identifier","C<create_class_type_constraint>"],[""," and the\n"],["Identifier","C<does>"],[""," variant will use "],["Identifier","C<create_role_type_constraint>"],["",".\n\n"],["Statement","=item"],[""," "],["Identifier","B<get_type_constraint_registry>"],["","\n\nReturns the "],["Identifier","L<Moose::Meta::TypeConstraint::Registry>"],[""," object which\nkeeps track of all type constraints.\n\n"],["Statement","=item"],[""," "],["Identifier","B<list_all_type_constraints>"],["","\n\nThis will return a list of type constraint names in the global\nregistry. You can then fetch the actual type object using\n"],["Identifier","C<find_type_constraint($type_name)>"],["",".\n\n"],["Statement","=item"],[""," "],["Identifier","B<list_all_builtin_type_constraints>"],["","\n\nThis will return a list of builtin type constraints, meaning those\nwhich are defined in this module. See the "],["Identifier","L<Default Type Constraints>"],["","\nsection for a complete list.\n\n"],["Statement","=item"],[""," "],["Identifier","B<export_type_constraints_as_functions>"],["","\n\nThis will export all the current type constraints as functions into\nthe caller's namespace ("],["Identifier","C<Int()>"],["",", "],["Identifier","C<Str()>"],["",", etc). Right now, this is\nmostly used for testing, but it might prove useful to others.\n\n"],["Statement","=item"],[""," "],["Identifier","B<get_all_parameterizable_types>"],["","\n\nThis returns all the parameterizable types that have been registered,\nas a list of type objects.\n\n"],["Statement","=item"],[""," "],["Identifier","B<add_parameterizable_type($type)>"],["","\n\nAdds "],["Identifier","C<$type>"],[""," to the list of parameterizable types\n\n"],["Statement","=back"],["","\n\n"],["Statement","=head1"],[""," "],["String","BUGS"],["","\n\nSee "],["Identifier","L<Moose/BUGS>"],[""," for details on reporting bugs.\n\n"],["Statement","=head1"],[""," "],["String","AUTHOR"],["","\n\nMoose is maintained by the Moose Cabal, along with the help of many contributors. See "],["Identifier","L<Moose/CABAL>"],[""," and "],["Identifier","L<Moose/CONTRIBUTORS>"],[""," for details.\n\n"],["Statement","=head1"],[""," "],["String","COPYRIGHT AND LICENSE"],["","\n\nThis software is copyright (c) 2013 by Infinity Interactive, Inc..\n\nThis is free software; you can redistribute it and/or modify it under\nthe same terms as the Perl 5 programming language system itself.\n\n"],["Statement","=cut"],["","\n"]]